(defun byte-pretty-op-arg-len (bytes off)
  (let* ((opcode (aref bytes off))
         (arg nil)
         (len 1))
    (cond ((< opcode byte-pophandler)
           (let ((tem (logand opcode 7)))
             (setq opcode (- opcode tem))
             (cond ((= tem 6)
                    (list opcode 0 2))
                   ((= tem 7)
                    (list opcode 0 3))
                   (t
                    (list opcode tem 1)))))
          ((>= opcode byte-constant)
           (list byte-constant (- opcode byte-constant) 1))
          ((or (and (>= opcode byte-constant2)
                    (<= opcode byte-goto-if-not-nil-else-pop))
               (memq opcode (list byte-stack-set2 byte-pushcatch
                                  byte-pushconditioncase)))
           (list opcode 0 3))
          ((and (>= opcode byte-listN)
                (<= opcode byte-discardN))
           (list opcode 0 2))
          (t (list opcode nil 1)))))

(defun byte-pretty-name-arg-len (bytes off)
  (let* ((tem (byte-pretty-op-arg-len bytes off))
         (opcode (car tem))
         (arg (cadr tem))
         (len (caddr tem))
         (type (cond ((memq opcode (mapcar #'symbol-value byte-goto-ops)) 'pc)
                     ((memq opcode (mapcar #'symbol-value byte-constref-ops)) 'cv)
                     (t 'stack-or-count)))
         (name (substring (symbol-name (aref byte-code-vector opcode)) 5)))
    (cond ((= len 3)
           (setq arg (+ arg (aref bytes (1+ off))
                        (lsh (aref bytes (+ 2 off)) 8)))
           (setq name (concat name " " (format "[%S]" arg))))
          ((= len 2)
           (setq arg (+ arg (aref bytes (1+ off))))
           (setq name (concat name " " (format "[%S]" arg))))
          (t
           (if arg (setq name (concat name "[" (format "%S" arg) "]")))))
    (list name (cons type arg) len)))

(defun byte-pretty-arg (arg constvec)
  (cond ((eq (car arg) 'cv)
         (format " %S" (aref constvec (cdr arg))))
        (t "")))

(defun byte-pretty-disassemble (bytes &optional constvec)
  (let ((beg 0)
        (end (length bytes))
        res)
    (while (< beg end)
      (let* ((tem (byte-pretty-name-arg-len bytes beg))
             (name (car tem))
             (arg (byte-pretty-arg (cadr tem) constvec))
             (len (caddr tem)))
        (push (cons beg (cons name arg)) res)
        (setq beg (+ beg len))))
    (nreverse res)))

(defun byte--pretty-bytes (bytes)
  (mapconcat (lambda (x) (format "%3d" x)) bytes " "))

(defun byte-pretty-compile-decompile-texinfo (form &optional optimize)
  "Compile FORM, then disassemble it, producing output suitable
for texinfo input."
  (let* ((byte-optimize optimize)
         (v (byte-compile form))
         (constvec (aref v 2))
         (bytes (aref v 1))
         (bytecode (byte-pretty-disassemble bytes constvec))
         (rbc (reverse bytecode))
         (pc (length bytes))
         (str "@end verbatim\n")
	 (width (max 2 (ceiling (log pc 10))))
	 (pc-width (format "%%%dd  " width))
	 (str-width (format "%%%ds " width))
	 )
    (if (> (length constvec) 0)
        (setq str (concat (format "\nConstants Vector: %S\n" constvec) str)))
    (while (> pc 0)
      (let* ((op (cdar rbc))
             (npc (caar rbc))
             (lstr ""))
        (while (< (1+ npc) pc)
          (setq str (concat "         "
                            (byte--pretty-bytes (substring bytes (1- pc) pc))
                            "\n"
                            str))
          (setq pc (1- pc)))
        (setq str (concat lstr
                          (format pc-width npc)
                          (byte--pretty-bytes (substring bytes npc (1+ npc)))
                          "   "
                          (car op)
                          (cdr op)
                          "\n"
                          str))
          (setq rbc (cdr rbc))
          (setq pc npc)))
    (setq str (format "@verbatim\n%s Byte  Instruction\n%s"
		      (format str-width "PC") str))
    str))

(defun byte-collect-comments (beg end)
  (let ((res nil))
    (goto-char beg)
    (while (search-forward-regexp "^ *\\([0-9]+\\).*?\\( *;;.*\\)$" end t)
      (push (cons (read (match-string 1)) (match-string 2))
            res))
    (goto-char end)
    res))

(defun byte-insert-comments (beg end comments)
  (setq end (copy-marker end))
  (goto-char beg)
  (while (search-forward-regexp "^ *\\([0-9]+\\) +[0-9].*$" end t)
    (let ((comment (alist-get (read (match-string 1)) comments)))
      (when comment
        (insert comment))))
  (goto-char end))

(defun byte-recalc-examples ()
  "Recalculate the examples in elisp-bytecode.texi"
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (search-forward-regexp "@code{\\([^}]*\\)} generates:$" nil t)
      (let* ((lexical (save-excursion
                        (beginning-of-line)
                        (while (not (looking-at-p ".*@code"))
                          (forward-line -1))
                        (looking-at-p ".*lexical")))
             (optimize (save-excursion
                         (beginning-of-line)
                         (while (not (looking-at-p ".*@code"))
                           (forward-line -1))
                         (looking-at-p ".*optimiz")))
             (code (read (match-string 1)))
             (form (cond ((eq (car-safe code) 'defun)
                          (eval code lexical))
                         (t
                          `(lambda () ,code))))
             (comments nil))
        (forward-char 1)
        (when (looking-at-p "^@verbatim$")
          (let* ((p0 (point))
                 (p1 (search-forward-regexp "@end verbatim\n*")))
            (setq comments (byte-collect-comments p0 p1))
            (delete-region p0 p1)))
        (let ((p0 (point)))
          (insert (byte-pretty-compile-decompile-texinfo form optimize))
          (byte-insert-comments p0 (point) comments)))
      (when (not (looking-at-p "\n\n"))
        (insert "\n")))))
