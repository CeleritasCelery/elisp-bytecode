(defun byte--pretty-bytes (bytes)
  (mapconcat (lambda (x) (format "%3d" x)) bytes " "))

(defun byte-pretty-compile-decompile (form)
  "Compile FORM, then disassemble it, producing a string listing
bytecode and LAP-code side-by-side."
  (let* ((v (byte-compile form))
         (constvec (aref v 2))
         (bytes (aref v 1))
         (bytecode (byte-decompile-bytecode bytes constvec))
         (rbc (reverse bytecode))
         (pc (length bytes))
         (str ""))
    (while (> pc 0)
      (if (eq (caar rbc) 'TAG)
          (setq rbc (cdr rbc))
        (let* ((op (car rbc))
               (npc (cadr rbc))
               (lstr ""))
          (while (eq (car-safe npc) 'TAG)
            (setq rbc (cdr rbc))
            (setq lstr (concat (format "%S:\n" npc) lstr))
            (setq npc (cadr rbc)))
          (while (< (1+ npc) pc)
            (setq str (concat "      "
                              (byte--pretty-bytes (substring bytes (1- pc) pc))
                              "\n"
                              str))
            (setq pc (1- pc)))
          (setq str (concat lstr
                            (format "%5d " npc)
                            (byte--pretty-bytes (substring bytes npc (1+ npc)))
                            " "
                            (format "%S\n" op)
                            str))
          (setq rbc (if (eq (car-safe op) 'TAG) (cdr rbc) (cddr rbc)))
          (setq pc npc))))
    str))

(defun byte-pretty-compile-decompile-texinfo (form)
  "Compile FORM, then disassemble it, producing output suitable
for texinfo input."
  (let* ((byte-optimize nil)
         (v (byte-compile form))
         (constvec (aref v 2))
         (bytes (aref v 1))
         (bytecode (byte-decompile-bytecode bytes constvec))
         (rbc (reverse bytecode))
         (pc (length bytes))
         (str "@end verbatim\n")
	 (width (max 2 (ceiling (log pc 10))))
	 (pc-width (format "%%%dd  " width))
	 (str-width (format "%%%ds " width))
	 )
    (if (> (length constvec) 0)
        (setq str (concat (format "\nConstant Vector: %S\n" constvec) str)))
    (while (> pc 0)
      (if (eq (caar rbc) 'TAG)
          (setq rbc (cdr rbc))
        (let* ((op (car rbc))
               (npc (cadr rbc))
               (lstr ""))
          (while (eq (car-safe npc) 'TAG)
            (setq rbc (cdr rbc))
            (setq lstr (concat (format "%S:\n" npc) lstr))
            (setq npc (cadr rbc)))
          (while (< (1+ npc) pc)
            (setq str (concat "         "
                              (byte--pretty-bytes (substring bytes (1- pc) pc))
                              "\n"
                              str))
            (setq pc (1- pc)))
          (setq str (concat lstr
                            (format pc-width npc)
                            (byte--pretty-bytes (substring bytes npc (1+ npc)))
                            "   "
                            (format "%S\n" op)
                            str))
          (setq rbc (if (eq (car-safe op) 'TAG) (cdr rbc) (cddr rbc)))
          (setq pc npc))))
    (setq str (format "@verbatim\n%s Byte  Instruction\n%s"
		      (format str-width "PC") str))
    str))

(defun byte-collect-comments (beg end)
  (let ((res nil))
    (goto-char beg)
    (while (search-forward-regexp "^ *\\([0-9]+\\).*?\\( *;;.*\\)$" end t)
      (push (cons (read (match-string 1)) (match-string 2))
            res))
    (goto-char end)
    res))

(defun byte-insert-comments (beg end comments)
  (setq end (copy-marker end))
  (goto-char beg)
  (while (search-forward-regexp "^ *\\([0-9]+\\) +[0-9].*$" end t)
    (let ((comment (alist-get (read (match-string 1)) comments)))
      (when comment
        (insert comment))))
  (goto-char end))

(defun byte-recalc-examples ()
  "Recalculate the examples in elisp-bytecode.texi"
  (interactive)
  (goto-char (point-min))
  (while (search-forward-regexp "@code{\\([^}]*\\)} generates:$" nil t)
    (let* ((lexical (save-excursion
                      (beginning-of-line)
                      (while (not (looking-at-p ".*@code"))
                        (forward-line -1))
                      (looking-at-p ".*lexical")))
           (code (read (match-string 1)))
           (form (cond ((eq (car-safe code) 'defun)
                        (eval code lexical))
                       (t
                        `(lambda () ,code))))
           (comments nil))
      (forward-char 1)
      (when (looking-at-p "^@verbatim$")
        (let* ((p0 (point))
               (p1 (search-forward-regexp "@end verbatim\n*")))
          (setq comments (byte-collect-comments p0 p1))
          (delete-region p0 p1)))
      (let ((p0 (point)))
        (insert (byte-pretty-compile-decompile-texinfo form))
        (byte-insert-comments p0 (point) comments)))
    (when (not (looking-at-p "\n\n"))
      (insert "\n"))))
