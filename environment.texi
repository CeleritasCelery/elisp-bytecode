@node Emacs Lisp Bytecode Environment
@chapter Emacs Lisp Bytecode Environment

In this chapter we will discuss the ways Emacs creates, modifies and
uses bytecode in order to run code. We describe a little of the two
kinds of interpreters Emacs has, what goes into a bytecode file, and
the interoperability of bytecode between versions.

@menu
* Emacs Lisp Bytecode Objects::
* Emacs Lisp Bytecode Compiler::
* Emacs Lisp Bytecode Interpreter::
* Emacs Lisp Bytecode Instructions::
* Emacs Lisp Bytecode Files::
@end menu

@node Emacs Lisp Bytecode Objects
@section Emacs Lisp Bytecode Objects

Emacs Lisp bytecode isn't a low-level sequence of octets (bytes) that
requires a lot of additional special-purpose machinery to run.  There
is however custom C code interpreter to handle each of the instruction
primitives, and that is basically it. And even here, many of the
instructions are simply a bytecode form of some existing Emacs
primitive function like ``car'' or ``point''.

Emacs Lisp bytecode is a built-in Emacs Lisp type (same as a say a
Lisp ``cons'' node, or a Lisp symbol). You can check if a value is
bytecode using the @code{byte-compile-function-p} predicate
function. Although there aren't methods to extract the components of
bytecode once it is built, the bytecode object is made up of other
normal Emacs Lisp objects described in @pxref{The Byte-code Function
Type and Literal}. Bytecode is created using the @code{byte-compile} function.

One important component of the bytecode object is the ``constants
vector.''  It contains important Lisp Objects that are required to
make sense of the bytecode-instruction operands: functions that share
the same bytecode-instruction byte string, but differ in their
constants vectors, can do very different things.

@node Emacs Lisp Bytecode Compiler
@section Emacs Lisp Bytecode Compiler

The Emacs Lisp Bytecode compiler is an ahead-of-time compiler that
accepts Emacs Lisp input and produces bytecode that can be run by
Emacs. The compiler itself is written in Emacs Lisp @footnote{usually,
the compiler itself is compiled into bytecode, which avoids overflow
problems}, and is a comparatively compact program contained in the
files @code{bytecomp.el} and @code{byte-opt.el}.

Internally, the compiler first produces an intermediate Lisp structure
in LAP code, then performs various optimizations on that, and finally
translates the LAP code into bytecode. LAP code is used during
compilation, but not kept in memory or used when running bytecode.
While it is possible to go back to LAP code from bytecode, this is
done only in order to inline functions.

@node Emacs Lisp Bytecode Interpreter
@section Emacs Lisp Bytecode Interpreter

When a function is called for which compiled bytecode is available,
control passes to the bytecode interpreter.  The interpreter is
written in C and heavily optimized for speed rather than readability.

The bytecode interpreter operates on a single function at a time; for
a function call, the bytecode interpreter calls other parts of Emacs,
which might call the bytecode interpreter again, recursively. Thus, in
contrast to languages like FORTH, there is no code stack per se, just
the C stack.

The bytecode interpreter implements a stack machine utilizing a
fixed-size evaluation stack, which is usually allocated as a block on
the C stack. Instructions can access either this stack or a constants
vector, which is produced at compile time and made part of the
bytecode object.

The evaluation stack, as well as the constants vector, contains Lisp
values, usually 64-bit words containing an integer (Emacs integers are
limited to 62 bits on 64-bit machines), symbol index, or a tagged
pointer to one of various Emacs structures such as markers, buffers,
floating-point numbers, vectors, or cons cells.

Values on the evaluation stack are created at run time; values in the
constants vector are created when the byte-compiled file is read and
converted into bytecode objects. The underlying bit representation of
values in the constants vector can vary between Emacs instances: they
are constants in the sense that they do not vary within a single Emacs
instance.

Bytecode objects contain a number safely estimating the maximum stack
size the evaluation stack can grow to.

@node Emacs Lisp Bytecode Instructions
@section Emacs Lisp Bytecode Instructions

The bytecode interpreter, once it has set up the evaluation stack and
constants vector, executes the instructions that make up the bytecode
byte string: each instruction is between one and three bytes in
length, containing an opcode in the first byte and sometimes an eight-
or 16-bit integer in the following bytes. Those integers are usually
unsigned, and 16-bit integers are stored in little-endian byte order,
regardless of whether that is the natural byte order for the machine
Emacs runs on.

Some opcodes, allocated in blocks, encode an integer as part of the
opcode byte.

Bytecode instructions operate on the evaluation stack: for example,
@code{plus}, the addition function, removes two values from the
top of the stack and pushes a single value, the sum of the first two
values, back on the stack.

Since the arguments for a function call need to be on the stack before
the function can operate on them, bytecode instructions use Reverse
Polish Notation: first the arguments are pushed on the stack, then the
function or operation is called.  For example, the Lisp expression
@code{(+ a b)} turns into this bytecode:

@c @code{(defun plus (a b) (+ a b))} generates
@verbatim
PC  Byte  Instruction
 0    8   varref a
 1    9   varref b
 2   92   plus
@end verbatim

First @code{a} and @code{b} are dereferenced and their values pushed
onto the evaluation stack; then @code{plus} is executed, leaving
only a single value, the sum of @code{a} and @code{b}, on the stack.

@node Emacs Lisp Bytecode Files
@section Emacs Lisp Bytecode Files

When Emacs is build from source code, there is C code for some
primitive or built-in functions. These include Lisp functions like
@code{car}, or primitive Emacs functions like @code{point}. Other
equally important functions are implemented in Emacs Lisp.  These are
byte compiled and then loaded into Emacs. On many systems there is the
ability to dump Emacs in some kind of image format after these basic
functions have been loaded. But even if that doesn't happen, a file
called @code{loaddefs.elc} is created that contains many of the
important basic primitive functions as bytecode.

When you invoke Emacs then, it has a number of functions already
loaded and these are either coded in C or have been byte compiled and
loaded. Before running a function, Emacs queries the type of code that
is associated with the function symbol and calls either its lambda
S-expression interpreter or its bytecode interpreter.

When you run @code{load}, which reads and evaluates Lisp code from a
file, at the top-level it doesn't matter whether the file contains
bytecode or Emacs Lisp source code. Either way the only thing done is
to open the file, and read the contents of the file using the normal
Lisp reader. The difference between the two kinds of files is more
about convention than it is strictly about the contents of the file.

The difference between a Emacs Lisp bytecode file and a Emacs Lisp
source file, then is two things. First the bytecode file will have a
comment header in it that starts @verb{|;ELC^W^@^@^@|} while the
source code probably doesn't. (However there's nothing to stop you
from adding in that line if you feel like it). In addition to this
comment header, a bytecode file will have other meta-comments such as
which version of Emacs was used to compile the file and whether
optimization was used. In earlier versions, there was information
about the program that was used to compile the program was given, like
its version number. And the source code path used to be in there as
well. (I think these things should still be in there but that's a
different story).  @xref{Opcode Changes Between Emacs Releases} where
we give examples of the headers to show how that has changed.

The second thing that is typically different between source code files
and bytecode files is the prevalence of the @code{byte-code} calls
used in the file and with the inclusion of those comes a lack of any
@code{defun}, @code{defmacro}, or @code{lambda} calls. But again I
suppose there's nothing stopping you from using doing likewise in your
source code.

In fact, you can take a file with the @code{.elc} extension, rename it
to have an @code{.el} extension instead and @code{load} that. And that
will run exactly the same if it had been loaded as a byte-code
file@footnote{If you go the other direction and rename a Lisp file as
a bytecode file, Emacs will notice the discrepency because at the top
of the file is a header that Emacs checks. But if you add a
reasonable-looking header you can go that direction as well.}.

Similarly, just as you can concatenate any number of independent Emacs
Lisp source code files into one file@footnote{and this is sometimes
done as a poor-man's way to create a package}, you can do the same
with Emacs Lisp bytecode files.

Of course, there will probably certain programs that are fooled when
the extension is changed. In particular, the
@code{byte-recompile-directory} function it will think that the
bytecode file doesn't exist because it has the wrong extension. So
even though Emacs is permissive about such matters, it is best to
stick with the normal Emacs conventions.

The final thing that should be mentioned when talking about bytecode
files is interoperability between Emacs versions.

Even though a bytecode header has a meta comment indicating the
version of Emacs that was used to compile it, that information is not
used in determining whether the bytecode file can be run or not.

This has the benefit of being able to run bytecode compiled in
different Emacs version than the version you are currently
running. Since Emacs bytecode instructions do not change that often,
this largely works.

Emacs developer(s) maintain that they try to keep backward
compatability between versions. In other words, bytecode that was
generated in an older version of Emacs but is no longer generated will
often still be interpreted in the new version of Emacs. While this is
a nice intention, the facts seem to suggest that this isn't always the
case. (Nor could it be in reality for a program that is 30 years old or
so).

@xref{Opcode Changes Between Emacs Releases} then for when this is
likely to work and in what cases it won't. And although running newer
bytecode in an older version of Emacs isn't explicitly considered,
again, since bytecode doesn't change that often, in reality this too
can sometimes work out.

Note that this is in sharp contrast other bytecode interpreters like
Python where the magic used in compiling has to be the same as the
value of running interpreter or Python will refuse to run.

Personally, I think it would be nice to have a Emacs Lisp bytecode
checker, perhaps a @code{safer-load} function that does look at the
bytecode and its meta-comments gleans when there is something that is
known to cause problems. Any voluneers?
