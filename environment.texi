@node Emacs Lisp Byte-Code Environment
@chapter Emacs Lisp Byte-Code Environment

In this chapter we will discuss the ways Emacs creates, modifies and
uses bytecode in order to run code. We describe a little of the two
kinds of interpreters Emacs has, what goes into a bytecode file, and
the interoperability of bytecode between versions.

@menu
* Byte-Code Objects::
* Byte-Code Compiler::
* Byte-Code Interpreter::
* Byte-Code Instructions::
* Byte-Code Files::
@end menu

@SECTION Byte-Code Objects

Emacs Lisp bytecode isn't a low-level sequence of octets (bytes) that
requires a lot of additional special-purpose machinery to run.  There
is however custom C code interpreter to handle each of the instruction
primitives, and that is basically it. And even here, many of the
instructions are simply a bytecode form of some existing Emacs
primitive function like ``car'' or ``point''.

Emacs Lisp bytecode is a built-in Emacs Lisp type (same as a say a
Lisp ``cons'' node, or a Lisp symbol). You can check if a value is
bytecode using the
@findex byte-compile-function-p
@code{byte-compile-function-p} predicate
@findex mapcar
@findex aref
function. Functions @code{aref} and @code{mapcar} can be used extract
the components of bytecode once it is built, the bytecode object is
made up of other normal Emacs Lisp objects described next. Byte code
is created using the
@findex make-byte-code
@code{make-byte-code} function.

One important component of the bytecode object is the ``constants
vector.''  It contains important Lisp Objects that are required to
make sense of the bytecode-instruction operands: functions that share
the same bytecode-instruction byte string, but differ in their
constants vectors, can do very different things.

@subsection The Byte-Code Function Type and Literal

@emph{This section is largely lifted from Chris Wellons' Emacs
byte code Internals.  See references at the end of this doc.}

An Emacs Lisp object of a byte code type is analogous to an Emacs Lisp
vector. As with a vector, elements are accessed in constant time.

The print syntax of this type is similar to vector syntax, except
@verb{|#[...]|} is displayed to display a bytecode literal instead of
(@verb{|[...]|} as is used in a vector.

In contrast to vector object, there are no functions to index or extract
parts of a code object once it is build, and a byte-code object can be
evaluated as a function.  Valid byte-code objects have 4 to 6 elements
and each element has a particular structure elaborated on below.

There are two ways to create a byte-code object: using a byte-code
object literal or with @code{make-byte-code}. Like vector literals,
byte-code functions don't need to be quoted.

Examples of calling @code{make-byte-code}:
@findex make-byte-code
@verbatim
(make-byte-code 0 "" [] 0)
;; => #[0 "" [] 0]

#[1 2 3 4]
;; => #[1 2 3 4]

(#[0 "" [] 0])
;; error: Invalid byte opcode
@end verbatim

The elements of a bytecode function literal are:
@iftex
@enumerate
@item Function Parameter (lambda) List
@item Byte-code Unibyte String
@item Constants Vector
@item Maximum Stack Usage
@item Docstring
@item ``Interactive'' Specification
@end enumerate
@end iftex
@menu
* Function Parameter (lambda) List::
* Byte-code Unibyte String::
* Constants Vector::
* Maximum Stack Usage::
* Docstring::
* Interactive Specification::
@end menu

@subsubsection Function Parameter (lambda) List
@node Function Parameter (lambda) List

The first element of a bytecode-function literal is the parameter list
for the @code{lambda}. The object takes on two different forms
depending on whether the function is lexically or dynamically scoped. If
the function is dynamically scoped, the argument list is exactly what
appears in Lisp code.

@b{Example showing how a parameter list is transformed:}
@findex byte-compile
@verbatim
(setq lexical-binding nil) ; force lexical binding
(byte-compile
  (lambda (a b &optional c) 5))
;; => #[(a b &optional c) "\300\207" [5] 1]
@end verbatim

Above we show raw bytecode data. in Emacs after versions after 25
efforts have been made to hide the data.

There's really no shorter way to represent the parameter list because
preserving the argument names is critical. Remember that, in dynamic
scope, while the function body is being evaluated these variables are
globally bound (eww!) to the function's arguments.

On the other hand, when the function is lexically scoped, the
parameter list is packed into an Emacs Lisp integer, indicating the counts
of the different kinds of parameters: required, @verb{|&optional|},
and @verb{|&rest|}. No variable names are needed.

The following shows how parameter counts and flags are encoded:

@image{elisp-params-small,,,,.png}

The least significant 7 bits indicate the number of required
arguments. Notice that this limits compiled, lexically-scoped
functions to 127 required arguments. The 8th bit is the number of
&rest arguments (up to 1). The remaining bits indicate the total
number of optional and required arguments (not counting &rest). It's
really easy to parse these in your head when viewed as hexadecimal
because each portion almost always fits inside its own ``digit.''

@b{Example showing how lexical parameters are encoded:}
@findex byte-compile-make-args-desc
@verbatim
(byte-compile-make-args-desc '())
;; => #x000  (0 args, 0 rest, 0 required)

(byte-compile-make-args-desc '(a b))
;; => #x202  (2 args, 0 rest, 2 required)

(byte-compile-make-args-desc '(a b &optional c))
;; => #x302  (3 args, 0 rest, 2 required)

(byte-compile-make-args-desc '(a b &optional c &rest d))
;; => #x382  (3 args, 1 rest, 2 required)
@end verbatim

The names of the arguments don't matter in lexical scope: they're
purely positional. This tighter argument specification is one of the
reasons lexical scope is sometimes faster: the byte-code interpreter doesn't
need to parse the entire lambda list and assign all of the variables
on each function invocation; furthermore, variable access is via a
compact index located usually in the operand value rather than an
index into the constants vector followed by a lookup of the variable.

@node Byte-code Unibyte String
@subsubsection Byte-code Unibyte String

The second element of a bytecode-function literal is a unibyte string
--- it strictly holds octets and is not to be interpreted as any sort
of Unicode encoding. These strings should be created with
unibyte-string because string may return a multibyte string. To
disambiguate the string type to the lisp reader when higher values are
present (> 127), the strings are printed in an escaped octal notation,
keeping the string literal inside the ASCII character set.

@b{Example of a unibyte string:}
@verbatim
(unibyte-string 100 200 250)
;; => "d\310\372"
@end verbatim

It's unusual to see a byte-code string that doesn't end with 135
(#o207, return). Perhaps this should have been implicit? I'll talk
more about the byte code below.

@node Constants Vector
@subsubsection Constants Vector

The third object in a bytecode-function literal is a constants
vector. It's a normal Emacs Lisp vector and can be created with
@code{(vector ...)} or a vector literal.

In addition to the normal kinds of things one thinks of as constants
--- numbers, strings, and compositions of these --- the constants
vector importantly contains symbol constants of those dynamic
variables and function names which are referred to by the instructions
of the byte-code unibyte string.

The amount of space used by an Emacs byte-code instruction, and the
number of ways an operand in an instruction can refer to an Lisp
object is rather limited. Most operands are only a few bits in length,
some fill an entire byte, and occasionally an operand can be two bytes
in length. Given this, you can't have an arbitrary string or
structured Lisp object listed directly inside an operand. Instead,
operands reference either the constants vector or they index into the
evaluation stack itself.


@b{Example showing a constants vector}:
@verbatim
ELISP> (byte-compile
        (lambda (a b)
         (my-func '("hi" "there") a nil 5)))
#[(a b)
  "\301\302\303\304$\207"
  [a my-func
     ("hi" "there")
     nil 5]
  5]
@end verbatim

The above assumes that dynamic binding is in effect.

The constants vector in the above example contains 5 elements:
@itemize
@item @code{a} --- the symbol @code{a} which refers to a variable
@item @code{myfunc} the symbol @code{myfunc} which likely refers to an external function
@item @code{("hi" "there")} a list constant containing two strings
@item @code{nil} the nil constant
@item @code{5} the integer constant 5
@end itemize

The properties of symbol @code{a} and symbol @code{myfunc} are
consulted at run time, so as such there is no knowledge in the
bytecode representing the fact that @code{a} is a dynamically-bound
parmeter while @code{my-func} is probably an external function.

If the lambda were a lexically-scoped, the constants vector would not
have the variable symbol @code{a} listed, but instead there would be a
stack entry.

Note that although the symbol @code{b} is a parameter of the lambda,
it doesn't appear in the constants vector, since it is not used in the
body of the function.

@node Maximum Stack Usage
@subsubsection Maximum Stack Usage

The fourth object in a bytecode-function literal is an integer which gives
the maximum stack space used by this byte-code. This value can be
derived from the byte code itself, but it's pre-computed so that the
byte-code interpreter can quickly check for stack
overflow. Under-reporting this value is probably another way to crash
Emacs.

In our example above, maximum-stack value is five since function
@code{myfunc} is called with four parameters which are pushed onto the
stack, and there is an additional stack entry pushed the @code{myfunc}
symbol itself. All of this needs to be in place on the stack just
before a @code{call} instruction runs to perform the @code{myfunc}
call.

@node Docstring
@subsubsection Docstring

The fifth object in a bytecode-function literal is simple and
completely optional. Depending on how the function was created the
docstring is either the docstring, or a cons cell indicating a
compiled `.elc` and a position for lazy access. Only one position, the
start, is needed because the lisp reader is used to load it and it
knows how to recognize the end.

@node Interactive Specification
@subsubsection ``Interactive'' Specification

When there is a sixth field in the bytecode-function the function is a
command, i.e an ``interative'' function.  Otherwise the function is
not a command.  That parameter holds the exactly contents of the
argument to @code{interactive} in the uncompiled function definition.
Note that @code{(interactive)} causes the sixth field to be nil,
which is distinct from there not being a sixth feild.

@b{Examples showing the interactive specification:}
@verbatim
ELISP> (byte-compile
         (lambda (n)
           (interactive "nNumber: ") n))
;; => #[(n) "\010\207" [n] 1 nil "nNumber: "]

ELISP> (byte-compile
         (lambda (n)
          (interactive (list (read))) n))
;; => #[(n) "\010\207" [n] 1 nil (list (read))]
@end verbatim

The interactive expression usually interpreted, which is fine because,
by definition, this code is going to be waiting on user
input. However, it slows down keyboard macro playback.


@SECTION Byte-Code Compiler

The Byte-Code compiler is an ahead-of-time compiler that
accepts Emacs Lisp input and produces bytecode that can be run by
Emacs. The compiler itself is written in Emacs Lisp @footnote{usually,
the compiler itself is compiled into bytecode, which avoids overflow
problems}, and is a comparatively compact program contained in the
files @code{bytecomp.el} and @code{byte-opt.el}.

Internally, the compiler first produces an intermediate Lisp structure
in LAP code, then performs various optimizations on that, and finally
translates the LAP code into bytecode. LAP code is used during
compilation, but not kept in memory or used when running bytecode.

It is possible to go back to LAP code from bytecode; this is done in
order to inline functions and when bytecode disassembly is requested.

@SECTION Byte-Code Interpreter

When a function is called and the function is represented as bytecode,
control passes to the bytecode interpreter.  The interpreter is
written in C and is written more for speed than readability.

The bytecode interpreter operates on a single function at a time; for
a function call, the bytecode interpreter calls other parts of Emacs,
which might call the bytecode interpreter again, recursively. Thus, in
contrast to languages like FORTH, there is no code stack per se, just
the C stack.

The bytecode interpreter implements a stack machine utilizing a
fixed-size evaluation stack, which is usually allocated as a block on
the C stack. Instructions can access either this stack or a constants
vector, which is produced at compile time and made part of the
bytecode object.

The evaluation stack, as well as the constants vector, contains Lisp
values, usually 64-bit words containing an integer (Emacs integers are
limited to 62 bits on 64-bit machines), symbol index, or a tagged
pointer to one of various Emacs structures such as markers, buffers,
floating-point numbers, vectors, or cons cells.

Values on the evaluation stack are created at run time; values in the
constants vector are created when the byte-compiled file is read and
converted into bytecode objects. The underlying bit representation of
values in the constants vector can vary between Emacs instances: they
are constants in the sense that they do not vary within a single Emacs
instance.

Bytecode objects contain a number safely estimating the maximum stack
size the evaluation stack can grow to.

@SECTION Byte-Code Instructions

The bytecode interpreter, once it has set up the evaluation stack and
constants vector, executes the instructions that make up the bytecode
byte string: each instruction is between one and three bytes in
length, containing an opcode in the first byte and sometimes an eight-
or 16-bit integer in the following bytes. Those integers are usually
unsigned, and 16-bit integers are stored in little-endian byte order,
regardless of whether that is the natural byte order for the machine
Emacs runs on.

Some opcodes, allocated in blocks, encode an integer as part of the
opcode byte.

Bytecode instructions operate on the evaluation stack: for example,
@code{plus}, the addition function, removes two values from the
top of the stack and pushes a single value, the sum of the first two
values, back on the stack.

Since the arguments for a function call need to be on the stack before
the function can operate on them, bytecode instructions use Reverse
Polish Notation: first the arguments are pushed on the stack, then the
function or operation is called.  For example, the Lisp expression
@code{(+ a b)} turns into this bytecode:

@c @code{(defun plus (a b) (+ a b))} generates
@verbatim
PC  Byte  Instruction
 0    8   varref a
 1    9   varref b
 2   92   plus
@end verbatim

First @code{a} and @code{b} are dereferenced and their values pushed
onto the evaluation stack; then @code{plus} is executed, leaving
only a single value, the sum of @code{a} and @code{b}, on the stack.

@SECTION Byte-Code Files

When Emacs is build from source code, there is C code for some
primitive or built-in functions. These include Lisp functions like
@code{car}, or primitive Emacs functions like @code{point}. Other
equally important functions are implemented in Emacs Lisp.  These are
byte compiled and then loaded into Emacs. On many systems there is the
ability to dump Emacs in some kind of image format after these basic
functions have been loaded. But even if that doesn't happen, a file
called @code{loaddefs.el} is created that contains many of the
important basic primitive functions as bytecode.

When you invoke Emacs then, it has a number of functions already
loaded and these are either coded in C or have been byte compiled and
loaded. Before running a function, Emacs queries the type of code that
is associated with the function symbol and calls either its lambda
S-expression interpreter or its bytecode interpreter.

When you run @code{load}, which reads and evaluates Lisp code from a
file, at the top-level it doesn't matter whether the file contains
bytecode or Emacs Lisp source code. Either way the only thing done is
to open the file, and read the contents of the file using the normal
Lisp reader. The difference between the two kinds of files is more
about convention than it is strictly about the contents of the file.

The difference between a Emacs Lisp bytecode file and a Emacs Lisp
source file, then is two things. First the bytecode file will have a
comment header in it that starts @verb{|;ELC^W^@^@^@|} while the
source code probably doesn't. (However there's nothing to stop you
from adding in that line if you feel like it). In addition to this
comment header, a bytecode file will have other meta-comments such as
which version of Emacs was used to compile the file and whether
optimization was used. In earlier versions, there was information
about the program that was used to compile the program was given, like
its version number. And the source code path used to be in there as
well. (I think these things should still be in there but that's a
different story).  @xref{Instruction Changes Between Emacs Releases} where
we give examples of the headers to show how that has changed.

The second thing that is typically different between source code files
and bytecode files is the prevalence of the @code{byte-code} calls
used in the file and with the inclusion of those comes a lack of any
@code{defun}, @code{defmacro}, or @code{lambda} calls. But again I
suppose there's nothing stopping you from using doing likewise in your
source code.

In fact, you can take a file with the @code{.elc} extension, rename it
to have an @code{.el} extension instead and @code{load} that. And that
will run exactly the same if it had been loaded as a byte code
file@footnote{If you go the other direction and rename a Lisp file as
a bytecode file, Emacs will notice the discrepency because at the top
of the file is a header that Emacs checks. But if you add a
reasonable-looking header you can go that direction as well.}.

Similarly, just as you can concatenate any number of independent Emacs
Lisp source code files into one file@footnote{and this is sometimes
done as a poor-man's way to create a package}, you can do the same
with Emacs Lisp bytecode files.

Of course, there will probably certain programs that are fooled when
the extension is changed. In particular, the
@code{byte-recompile-directory} function it will think that the
bytecode file doesn't exist because it has the wrong extension. So
even though Emacs is permissive about such matters, it is best to
stick with the normal Emacs conventions.

The final thing that should be mentioned when talking about bytecode
files is interoperability between Emacs versions.

Even though a bytecode header has a meta comment indicating the
version of Emacs that was used to compile it, that information is not
used in determining whether the bytecode file can be run or not.

This has the benefit of being able to run bytecode compiled in
different Emacs version than the version you are currently
running. Since Emacs bytecode instructions do not change that often,
this largely works. The scary part though is that opcode meanings have
changed over the 30 years, and the interpreter is and has been
sometimes lacking in checks. (In the past the interpreter has aborted
when running an invalid bytecode). So Emacs doesn't even know that you
are running bytecode from a different interpreter. There is no check
that you aren't going off a cliff running older or newer bytecode.

However, Emacs developer(s) maintain that in practice problems haven't
occurred with such frequency that it has been reported happened enough
to be a problem.  Also, they try to keep backward compatability
between versions. In other words, bytecode that was generated in an
older version of Emacs but is no longer generated will often still be
interpreted in the new version of Emacs. While this is a nice
intention, the facts seem to suggest that this isn't always the
case. (Nor could it be in reality for a program that is 30 years old
or so).

@xref{Instruction Changes Between Emacs Releases} then for when this is
likely to work and in what cases it won't. And although running newer
bytecode in an older version of Emacs isn't explicitly considered,
again, since bytecode doesn't change that often, in reality this too
can sometimes work out.

Note that this is in sharp contrast other bytecode interpreters like
Python where the magic used in compiling has to be the same as the
value of running interpreter or Python will refuse to run.

Personally, I think it would be nice to have a Emacs Lisp bytecode
checker, perhaps a @code{safer-load} function that does look at the
bytecode and its meta-comments gleans when there is something that is
known to cause problems. Any voluneers?
