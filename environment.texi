@node Emacs Lisp Bytecode Environment
@chapter Emacs Lisp Bytecode Environment

In this chapter we discuss the ways Emacs creates, modifies and
uses bytecode in order to run code. We describe a little of the two
kinds of interpreters Emacs has, what goes into a bytecode file, and
the interoperability of bytecode between versions.

@menu
* Emacs Lisp Bytecode Objects::
* Emacs Lisp Bytecode Compiler::
* Emacs Lisp Bytecode Interpreter::
* Emacs Lisp Bytecode Bytes::
* Emacs Lisp Bytecode Files::
* Functions and Commands for working with LAP and Bytecode::
* Bytecode Optimization::
@end menu

@SECTION Emacs Lisp Bytecode Objects
@cindex bytecode

@emph{This section is expanded and edited from Chris Wellons' blog on
``Emacs byte code Internals'' and from the Emacs Lisp Reference
manual. See references at the end of this doc.}

Emacs Lisp bytecode is an encoded form of a low-level assembly format
that is suited to running Emacs Lisp primitives and functions.

Emacs Lisp bytecode is not a low-level sequence of octets (bytes) that
requires a lot of additional special-purpose machinery to run.  There
is a custom C code interpreter to handle each of the instruction
primitives, and that is basically it. And even here, many of the
instructions are simply a bytecode form of some existing Emacs
primitive function like ``car'' or ``point''.

Emacs Lisp bytecode is a built-in Emacs Lisp type (the same as a
Lisp ``cons'' node, or a Lisp symbol).

Functions @code{aref} and @code{mapcar} can be used to extract the
components of bytecode once it is built, The bytecode object is made
up of other normal Emacs Lisp objects described next. Bytecode is
created using the
@findex make-byte-code
@code{make-byte-code} function.

One important component of the bytecode object is the ``constants
vector.''  It is a Emacs Lisp vector. The @code{constant} instruction
refers to one of these objects.

An Emacs Lisp object of a bytecode type is analogous to an Emacs Lisp
vector. As with a vector, elements are accessed in constant time.

The print syntax of this type is similar to vector syntax, except
@verb{|#[...]|} is displayed to display a bytecode literal instead of
@verb{|[...]|} as in a vector.

A bytecode object is one of the several kinds of functions that Emacs
understands. See @pxref{symbol-function} for other objects that act
like a function.

Valid bytecode objects have 4 to 6 elements and each element has a
particular structure elaborated on below.

There are two ways to create a bytecode object: using a bytecode
object literal or with @code{make-byte-code} (@pxref{make-byte-code}). Like vector literals,
bytecode functions don't need to be quoted.

The elements of a bytecode function literal are:
@iftex
@enumerate
@item Function Parameter (lambda) List
@item Bytecode Unibyte String
@item Constants Vector
@item Maximum Stack Usage
@item Docstring
@item ``Interactive'' Specification
@end enumerate
@end iftex
@menu
* Function Parameter (lambda) List::
* Bytecode Unibyte String::
* Constants Vector::
* Maximum Stack Usage::
* Docstring::
* Interactive Specification::
@end menu

@node Function Parameter (lambda) List
@subsection Function Parameter (lambda) List

The first element of a bytecode-function literal is the parameter list
for the @code{lambda}. The object takes on two different forms
depending on whether the function is lexically or dynamically
scoped. If the function is dynamically scoped, the argument list is a
list and is exactly what appears in Lisp code. In this case, the
arguments will be dynamically bound before executing the bytecode.

@b{Example showing how a parameter list is transformed:}

@findex byte-compile
@verbatim
ELISP> (setq lexical-binding nil) ; force lexical binding
ELISP> (byte-compile
  (lambda (a b &optional c) 5))

#[(a b &optional c) "\300\207" [5] 1]
@end verbatim

Above we show raw bytecode data. Emacs after version 25
makes an effort to hide the data.

There is really no shorter way to represent the parameter list because
preserving the argument names is critical. With dynamic
scoping, while the function body is being evaluated these variables are
globally bound (eww!) to the function's arguments.

On the other hand, when the function is lexically scoped, the
parameter list is packed into an Emacs Lisp integer, indicating the
counts of the different kinds of parameters: required,
@verb{|&optional|}, and @verb{|&rest|}. No variable names are
needed. In contrast to dynamically-bound variables, the arguments
are on the stack of the byte-code interpreter before executing the
code

The following shows how parameter counts and flags are encoded:

@image{elisp-params-small,,,,.png}

The least significant 7 bits indicate the number of required
arguments. This limits compiled, lexically-scoped
functions to 127 required arguments. The 8th bit is the number of
@b{&rest} arguments (up to 1). The remaining bits indicate the total
number of optional and required arguments (not counting @b{&rest}). It's
really easy to parse these in your head when viewed as hexadecimal
because each portion almost always fits inside its own ``digit.''

@b{Examples showing how lexical parameters are encoded:}

@findex byte-compile-make-args-desc
@verbatim
ELISP> (byte-compile-make-args-desc '())

#x000  ;; (0 args, 0 rest, 0 required)

ELISP> (byte-compile-make-args-desc '(a b))

#x202  ;; (2 args, 0 rest, 2 required)

ELISP> (byte-compile-make-args-desc '(a b &optional c))

#x302  ;; (3 args, 0 rest, 2 required)

ELISP> (byte-compile-make-args-desc '(a b &optional c &rest d))

#x382  ;; (3 args, 1 rest, 2 required)
@end verbatim

The names of the arguments do not matter in lexical scope; they're
purely positional. This tighter argument specification is one of the
reasons lexical scope is sometimes faster: the byte-code interpreter doesn't
need to parse the entire lambda list and assign all of the variables
on each function invocation; furthermore, variable access is via a
compact index located usually in the operand value rather than an
index into the constants vector followed by a lookup of the variable.

@node Bytecode Unibyte String
@subsection Bytecode Unibyte String

The second element of a bytecode-function literal is either

@itemize
@item
a unibyte string, or
@item
a pointer to a unibyte string,
@item
An autoload function
@end itemize

A unibyte string is a sequence of bytes or octets. Despite the type
name, it is not interpreted with any sort of Unicode
encoding. These sequences should be created with
@code{unibyte-string()} because strings can get transformed into longer
sequences of bytes when encoded. To disambiguate the string type to
the Lisp reader when higher values are present (> 127), the strings
are printed in an escaped octal notation, keeping the string literal
inside the ASCII character set.

@b{Examples unibyte strings:}

Bytecode for @code{(defun double-eg(n) (+ n n))} is:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] n
 1  137   dup
 2   92   plus
 3  135   return

Constants Vector: [n]
@end verbatim

To encode the byte sequence then for this we could use:
@verbatim
ELISP> (unibyte-string 8 127 92 135)

"^H^?\\\207"
@end verbatim

It is unusual to see a bytecode string that doesn't end with 135
(#o207, return).

We describe how to decode the bytecode string in @ref{Instruction-Description Format}.

However when a function has been defined as a result of reading a
bytecode file, the unibyte string is a pointer into that file. This
pointer is represented by a @code{cons} node where the @code{car} is the
filename and the @code{cdr} is the bytecode offset from the beginning of the file

@verbatim
ELISP> (aref
        (symbol-function 'cl-gcd)
        1) ;; 1 is the bytecode string field

"("/tmp/emacs/lisp/emacs-lisp/cl-extra.elc" . 7352)
@end verbatim

@verbatim
ELISP> (aref
        (symbol-function 'ediff-buffers)
        1)

(autoload "ediff" 975154 t nil)
@end verbatim


@node Constants Vector
@subsection Constants Vector

@cindex constants vector
The third object in a bytecode-function literal is the ``constants
vector''. It is a normal Emacs Lisp vector and can be created with
@code{(vector ...)} or using a vector literal.

There is a possiblity for confusion by the name ``constants vector''.
The vector size and its values are indeed constant. Also, only the
@code{constant} bytecode instruction refers to one of these objects.
However, in addition to values string and integer values that do not
change, values in this vector also can be function and variable
names. So although a variable or function @emph{name} stored in the
constants vector doesn't change, the @emph{binding} of that particular
variable or function can change, even in the course of running the
bytecode.

The reason for the constants vector is that it reduces the amount of
space needed in an instruction's operand. Instead of an arbitrary
string stored as the operand of some instruction, there is only
a small-value index into a vector. (It alos happens that this appears only
in one instruction.)  Furthermore, since the constants vector is a
true Emacs Lisp vector, the overall bytecode interpreter is simpler:
all Lisp objects are handled in a unified way. For example there is no
special representation of an integer in bytecode that is different
than the representation in the Emacs Lisp interpreter.

@b{Example Showing a Constants Vector:}
@verbatim
ELISP> (aref
        (byte-compile
          (lambda (a b)
           (my-func '("hi" "there") a nil 5)))
	 2) ;; 2 is the bytecode constants field

[a my-func
 ("hi" "there")
  nil 5]
@end verbatim

The above assumes that dynamic binding is in effect.

The constants vector in the above example contains 5 elements:
@itemize
@item @code{a} --- the symbol @code{a} which refers to a variable
@item @code{myfunc} ---the symbol @code{myfunc} which likely refers to an external function
@item @code{("hi" "there")} --- a list constant containing two strings
@item @code{nil} --- the nil constant
@item @code{5} --- the integer constant 5
@end itemize

The properties of symbol @code{a} and symbol @code{myfunc} are
consulted at run time, so there is no knowledge in the
bytecode representing the fact that @code{a} is a dynamically-bound
parmeter while @code{my-func} is probably an external function.

If the lambda were lexically scoped, the constants vector would not
have the variable symbol @code{a} listed, but instead there would be a
stack entry.

Note that although the symbol @code{b} is a parameter of the lambda,
it does not appear in the constants vector, since it is not used in the
body of the function.

@node Maximum Stack Usage
@subsection Maximum Stack Usage

The fourth object in a bytecode-function literal is an integer which gives
the maximum stack space used by this bytecode. This value can be
derived from the bytecode itself, but it is pre-computed so that the
byte-code interpreter can quickly check for stack
overflow. Under-reporting this value is probably another way to crash
Emacs.

In our example above, the maximum-stack value is five since function
@code{myfunc} is called with four parameters which are pushed onto the
stack, and there is an additional stack entry pushed, the @code{myfunc}
symbol itself. All of this needs to be in place on the stack just
before a @code{call} instruction runs to perform the @code{myfunc}
call.

@node Docstring
@subsection Docstring

The fifth object in a bytecode-function literal. It is optional.  As
with the bytecode unibyte string, this value is either a string
literal or a pointer to a string in a bytecode file.

@b{Examples showing DocStrings:}

@verbatim
ELISP> (aref
	(byte-compile
	 (defun double(a)
	  "double parameter A"
	  (+ a a)))
	4) ;; 4 is the bytecode docstring field

"double parameter A"


ELISP> (aref
	(symbol-function 'cl-gcd)
	 4)

("/tmp/emacs/lisp/emacs-lisp/cl-extra.elc" . 7251)
@end verbatim


@node Interactive Specification
@subsection ``Interactive'' Specification

When there is a sixth field in the bytecode function, the function is a
command, i.e., an ``interactive'' function.  Otherwise the function is
not a command.  This parameter holds the exact contents of the
argument to @code{interactive} in the uncompiled function definition.
Note that @code{(interactive)} causes the sixth field to be nil,
which is distinct from there not being a sixth field.

@unnumberedsubsec Examples showing the ``interactive'' specification

@verbatim
ELISP> (aref
         (byte-compile
           (lambda (n)
            (interactive "nNumber: ") n)
            )
         5) ;; 5 is the bytcode interactive specification field

"nNumber: "

ELISP> (aref
         (byte-compile
          (lambda (n)
           (interactive (list (read))) n))
         5)

(list
  (read))

@end verbatim

The interactive expression is usually interpreted, which is fine because,
by definition, this code is going to be waiting on user
input, but it slows down keyboard macro playback.


@SECTION Emacs Lisp Bytecode Compiler

The bytecode compiler is an ahead-of-time compiler that
accepts Emacs Lisp input and produces bytecode that can be run by
Emacs. The compiler itself is written in Emacs Lisp @footnote{Usually
the compiler itself is compiled into bytecode, which avoids overflow
problems}, and is a comparatively compact program contained in the
files @code{bytecomp.el} and @code{byte-opt.el}.

Internally, the compiler first produces an intermediate Lisp structure
in LAP code, then performs various optimizations on that, and finally
translates the LAP code into bytecode. LAP code is used during
compilation, but not kept in memory or used when running bytecode.

It is possible to go back to LAP code from bytecode. This is done in
order to inline functions and when bytecode disassembly is requested.

@SECTION Emacs Lisp Bytecode Interpreter

When a function is called and the function is represented as bytecode,
control passes to the bytecode interpreter.  The interpreter is
written in C and is written more for speed than readability.

The bytecode interpreter operates on a single function at a time. For
a function call, the bytecode interpreter calls other parts of Emacs,
which might call the bytecode interpreter again, recursively. Thus, in
contrast to languages like FORTH, there is no code stack per se, just
the C stack.

The bytecode interpreter implements a stack machine utilizing a
fixed-size evaluation stack, which is usually allocated as a block on
the C stack. Instructions can access either this stack or a constants
vector, which is produced at compile time and made part of the
bytecode object.

The evaluation stack, as well as the constants vector, contains Lisp
values, usually 64-bit words containing an integer (Emacs integers are
limited to 62 bits on 64-bit machines), symbol index, or a tagged
pointer to one of various Emacs structures such as markers, buffers,
floating-point numbers, vectors, or cons cells.

Values on the evaluation stack are created at run time. Values in the
constants vector are created when the byte-compiled file is read and
converted into bytecode objects. The underlying bit representation of
values in the constants vector can vary between Emacs instance; they
are constants in the sense that they do not vary within a single Emacs
instance.

Bytecode objects contain a number safely estimating the maximum stack
size the evaluation stack can grow to.

@SECTION Emacs Lisp Bytecode Bytes

The bytecode interpreter, once it has set up the evaluation stack and
constants vector, executes the instructions that make up the bytecode
byte sequence. Each instruction is between one and three bytes long,
containing an opcode in the first byte and sometimes an eight- or
16-bit integer in the following bytes. Those integers are usually
unsigned, and 16-bit integers are stored in little-endian byte order,
regardless of whether that is the natural byte order for the machine
Emacs runs on.

Some opcodes, allocated in blocks, encode an integer as part of the
opcode byte.

Bytecode instructions operate on the evaluation stack. For example,
@code{plus}, the addition function, removes two values from the
top of the stack and pushes a single value, the sum of the first two
values, back onto the stack.

Since the arguments for a function call need to be on the stack before
the function can operate on them, bytecode instructions use reverse
Polish notation: first the arguments are pushed onto the stack, then the
function or operation is called.  For example, the Lisp expression
@code{(+ a b)} turns into this bytecode:

@c @code{(defun plus (a b) (+ a b))} generates
@verbatim
PC  Byte  Instruction
 0    8   varref a
 1    9   varref b
 2   92   plus
@end verbatim

First @code{a} and @code{b} are dereferenced and their values pushed
onto the evaluation stack; then @code{plus} is executed, leaving
only a single value, the sum of @code{a} and @code{b}, on the stack.

@SECTION Emacs Lisp Bytecode Files

When Emacs is build from source code, there is C code for some
primitive or built-in functions. These include Lisp functions like
@code{car}, or primitive Emacs functions like @code{point}. Other
equally important functions are implemented in Emacs Lisp.  These are
byte compiled and then loaded into Emacs. On many systems there is the
ability to dump Emacs in some kind of image format after these basic
functions have been loaded, but even if that does not happen, a file
called @code{loaddefs.el} is created which contains many of the
important basic primitive functions as bytecode.

When we invoke Emacs then, it has a number of functions already
loaded and these are either coded in C or have been byte compiled and
loaded. Before running a function, Emacs queries the type of code that
is associated with the function symbol and calls either its lambda
S-expression interpreter or its bytecode interpreter.

When we run @code{load}, which reads and evaluates Lisp code from a
file, at the top-level it does not matter whether the file contains
bytecode or Emacs Lisp source code. Either way the only thing done is
to open the file and read its contents using the normal
Lisp reader.


The difference between the two kinds of files is more about convention
than about their contents, and specifically two things: First the
bytecode file will have a comment header in it that starts
@verb{|;ELC^W^@^@^@|} while the source code probably does not
(although nothing to stop us from adding in that line if we feel like
it). And, in addition to this comment header, a bytecode file will
have other meta-comments such as which version of Emacs was used to
compile the file and whether optimization was used. In earlier
versions, there was information about the program that was used to
compile the program, such its version number, and the source code path
used to be in there as well. (I think these things should still be in
there but that's a different story.)  See @ref{Instruction Changes
Between Emacs Releases} where we give examples of the headers to show
how they have changed.

The second thing that is typically different between source code files
and bytecode files is that bytecode files contain the @code{bytecode}
calls used in the file and lack of any @code{defun}, @code{defmacro},
or @code{lambda} calls. But again there is presumably nothing stopping
anyone from using these in their source code.

In fact, we can take a file with the @code{.elc} extension, rename it
with an @code{.el} extension and @code{load} that, and it
will run exactly the same if it had been loaded as a bytecode
file@footnote{If we go the other way and rename a Lisp file as
a bytecode file, Emacs will notice the discrepency because at the top
of the file is a header that Emacs checks. But if we add a
reasonable-looking header we can go that direction as well.}.

Similarly, just as we can concatenate any number of independent Emacs
Lisp source code files into one file, and this is sometimes done as a
poor-man's way to create a package, we can also concantenate any
numbers of Emacs Lisp bytecode files.

Of course, there are probably certain programs that are fooled when
the extension is changed. In particular, the
@code{byte-recompile-directory} function will think that the
bytecode file does not exist because it has the wrong extension. So
even though Emacs is permissive about such matters, it is best to
stick with the normal Emacs conventions.

The final thing that should be mentioned when talking about bytecode
files is interoperability between Emacs versions.

Even though a bytecode header has a meta comment indicating the
version of Emacs that was used to compile it, that information is not
used in determining whether the bytecode file can be run or not.  This
has the benefit of being able to run bytecode compiled in a different
Emacs version than the version currently running. Since Emacs bytecode
instructions do not change often, this largely works. The scary part,
though, is that opcode meanings have changed over the 30 years, and
the interpreter sometimes lacks checks. (In the past the interpreter
aborted when running an invalid bytecode.) So Emacs does not even know
when we are running bytecode from a different interpreter, and we
might run off a cliff running older or newer bytecode without a check.

Emacs developers maintain that, in practice, problems have not been
reported very much.  Also, they try to keep backward compatability
between versions so that bytecode generated in an older version of
Emacs will often still be interpreted in a recent newer version. While
this is a worthwhile intention, my experience is that this does not
always work, especially going back more than one version, and it is
unrealistic to expect for a program that is 30 years old.

Because there is no up-front checking, bytecode generated from a newer
version of Emacs will run silently on an older version until there is
opcode that the older version cannot handle. In some cases it will
complete.  See @ref{Instruction Changes Between Emacs Releases} for
when this is likely to work and when it won't. Although running newer
bytecode in an older version of Emacs is not explicitly considered,
since bytecode does not change very often, this can sometimes work
out.

Note the sharp contrast with other bytecode interpreters, such as
Python, where the magic used in compiling has to be the same as the
value of the running interpreter or it will refuse to run.

It would be nice to have an Emacs Lisp bytecode
checker, perhaps a @code{safer-load} function that looks at the
bytecode. Its meta-comments would glean when there is something that is
known to cause problems. Any volunteers?

@SECTION Functions and Commands for working with LAP and Bytecode

You can byte-compile an individual function or macro definition with
the @code{byte-compile} function. To extract individual components of
that array use @code{aref}. To recover human-readable LAP code from
a byte-compiled file use @code{dissasemble}. Perhaps in the future there
will be a decompiler which reconstructs higher-level Lisp from LAP.

You can see if a symbol's value holds one of the function types or an
alias to a function with @code{functionp}.  To retrieve the definition
of the function use @code{symbol-function}.

You can compile a whole file with @code{byte-compile-file}, or several
files with @code{byte-recompile-directory} or
@code{batch-byte-compile}.

@vindex byte-compile-debug
 Sometimes, the byte compiler produces warning and/or error messages
(@pxref{Compiler Errors,,,elisp, GNU Emacs Lisp Reference Manual}, for
details).  These messages are normally recorded in a buffer called
@file{*Compile-Log*}, which uses compilation mode.  @xref{Compilation
Mode,,,emacs, The GNU Emacs Manual}.  However, if the variable
@code{byte-compile-debug} is non-nil, error message will be signaled
as Lisp errors instead (@pxref{Errors,,,elisp, GNU Emacs Lisp
Reference Manual}).

@cindex macro compilation
Be careful when writing macro calls in files that you intend to
byte-compile.  Since macro calls are expanded when they are compiled,
the macros need to be loaded into Emacs or the byte compiler will not
do the right thing.  The usual way to handle this is with
@code{require} forms which specify the files containing the needed
macro definitions (@pxref{Named Features,,,elisp, GNU Emacs Lisp
Reference Manual}).  Normally, the byte compiler does not evaluate the
code that it is compiling, but it handles @code{require} forms
specially, by loading the specified libraries.  To avoid loading the
macro definition files when someone runs the compiled program,
write @code{eval-when-compile} around the @code{require} calls
(@pxref{Eval During Compile,,,elisp, GNU Emacs Lisp Reference
Manual}). @xref{Compiling Macros,,,elisp, GNU Emacs
Lisp Reference Manual} for more details.

Inline (@code{defsubst}) functions are less troublesome. If you
compile a call to such a function before its definition is known, the
call will still work right; it will just run slower.

In the list below, some of the functions are somewhat general and are
not specific to bytecode. however they are mentioned because they are
specifically have an interesting use in bytecode and their connection
might be readily appearent.

@menu
* aref-fn::  aref
* batch-byte-compile::
* batch-byte-recompile-directory::
* byte-code::
* byte-compile::
* byte-compile-file::
* byte-compile-sexp::
* byte-recalc-examples::
* byte-recompile-directory::
* byte-recompile-file::
* compile-defun::
* disassemble::
* disassemble-file::
* disassemble-full::
* display-call-tree::
* functionp::
* make-byte-code::
* symbol-function-fn:: symbol-function
@end menu

@node aref-fn
@subsection @code{aref}

@defun aref arry idx
Return the element of @var{array} at index @var{idx}.

Use this to extract the individual components of a byte-code object.
@xref{Emacs Lisp Bytecode Objects} for numerous examples using @code{aref}.
@end defun

@example
@group
ELISP> (aref
        (symbol-function 'cl-gcd)
        1) ;; 1 is the bytecode string field

"("/tmp/emacs/lisp/emacs-lisp/cl-extra.elc" . 7352)
@end group
@end example


@node batch-byte-compile
@subsection @code{batch-byte-compile}

@defun batch-byte-compile &optional noforce
This function runs @code{byte-compile-file} on files specified on the
command line.  This function must be used only in a batch execution of
Emacs, as it kills Emacs on completion.  An error in one file does not
prevent processing of subsequent files, but no output file will be
generated for it, and the Emacs process will terminate with a nonzero
status code.

If @var{noforce} is non-@code{nil}, this function does not recompile
files that have an up-to-date @samp{.elc} file.

@example
$ emacs -batch -f batch-byte-compile *.el
@end example
@end defun

@node batch-byte-recompile-directory
@subsection @code{batch-byte-recompile-directory}

@defun batch-byte-recompile-directory directory &optional arg
Run @code{byte-recompile-directory} on the dirs remaining on the command line.
Must be used only with @code{-batch}, and kills Emacs on completion.
For example, invoke @code{emacs -batch -f batch-byte-recompile-directory .}.

Optional argument @var{arg} is passed as second argument @var{arg} to
@code{byte-recompile-directory}; see there for its possible values
and corresponding effects.
@end defun

@node byte-code
@subsection @code{byte-code}

@defun byte-code bytestr vector maxdepth
This function is executes byte code and is used internally in
byte-compiled code.  The first argument, @var{bytestr}, is a string of
byte code; the second, @var{vector}, a vector of constants; the third,
@var{maxdepth}, the maximum stack depth used in this function.  If the
third argument is incorrect, Emacs may crash.
@end defun

@example
@group
ELISP> (setq msg-string "hi")
"hi"
ELISP> (byte-code "\301!\207" [msg-string message] 2)
"hi"
@end group
@end example


@node byte-compile
@subsection @code{byte-compile}

@deffn Command byte-compile form
If @var{form} is a symbol, byte-compile its function definition.

@example
@group
(defun factorial (integer)
  "Compute factorial of INTEGER."
  (if (= 1 integer) 1
    (* integer (factorial (1- integer)))))
@result{} factorial
@end group

@group
(byte-compile 'factorial)
@result{}
#[(integer)
  "^H\301U\203^H^@@\301\207\302^H\303^HS!\"\207"
  [integer 1 * factorial]
  4 "Compute factorial of INTEGER."]
@end group
@end example

If @var{form} is a lambda or a macro, byte-compile it as a function.

@example
@group
(byte-compile
  (lambda (a) (* a a)))
@result{}
  #[(a) "^H\211\207" [a] 2]
@end group
@end example

If @var{symbol}'s definition is a bytecode function object,
@code{byte-compile} does nothing and returns @code{nil}.  It does not
compile the symbol's definition again, since the original
(non-compiled) code has already been replaced in the symbol's function
cell by the byte-compiled code.

@end deffn


@node byte-compile-file
@subsection @code{byte-compile-file}

@deffn Command byte-compile-file filename &optional load
This function compiles a file of Lisp code named @var{filename} into a
file of bytecode.  The output file's name is made by changing the
@samp{.el} suffix into @samp{.elc}. If @var{filename} does not end in
@samp{.el}, it adds @samp{.elc} to the end of @var{filename}.

Compilation works by reading the input file one form at a time.  If it
is a definition of a function or macro, the compiled function or macro
definition is written out.  Other forms are batched, then each
batch is compiled, and written so that its compiled code will be
executed when the file is read.  All comments are discarded when the
input file is read.

This command returns @code{t} if there are no errors and @code{nil}
otherwise.  When called interactively, it prompts for the file name.

If @var{load} is non-@code{nil}, this command loads the compiled file
after compiling it.  Interactively, @var{load} is the prefix argument.

@example
@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
@end group

@group
(byte-compile-file "~/emacs/push.el")
     @result{} t
@end group

@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc
@end group
@end example
@end deffn

@node byte-compile-sexp
@subsection @code{byte-compile-sexp}

@defun byte-compile-sexp sexp

Bytecode compile and return @var{sexp}.

This can be useful for seeing what the byte compile does, especially
when combined with @code{disassemble}.

@example
@group

ELISP> (disassemble
         (byte-compile-sexp '(1+ fill-column)))
byte code:
  args: nil
0	varref	  fill-column
1	add1
2	return
@end group
@end example

@example
@group
ELISP> (disassemble
         (byte-compile-sexp
           '(unwind-protect (1+ fill-column) (ding))))

byte code:
  args: nil
0	constant  <compiled-function>
      args: nil
    0	    constant  ding
    1	    call      0
    2	    return

1	unwind-protect
2	varref	  fill-column
3	add1
4	unbind	  1
5	return
@end group
@end example
@end defun

@node byte-recalc-examples
@subsection @code{byte-recalc-examples}
@deffn Command byte-recalc-examples begin end
This command is what we use in this document to format our examples. It is
not part of Emacs lisp but in @code{byte-pretty.el} inside the repository where
this document lives.

Since we want to show values of various kinds --- offsets, opcodes,
operand, and constant-vector values --- this output is a more verbose than the format
you get from the @code{disassemble} command.
@end deffn


@node byte-recompile-directory
@subsection @code{byte-recompile-directory}

@deffn Command byte-recompile-directory directory &optional flag force
@cindex library compilation
This command recompiles every @samp{.el} file in @var{directory} (or
its subdirectories) that needs recompilation.  A file needs
recompilation if an @samp{.elc} file exists but is older than the
@samp{.el} file.

When a @samp{.el} file has no corresponding @samp{.elc} file,
@var{flag} says what to do.  If it is @code{nil}, this command ignores
these files.  If @var{flag} is 0, it compiles them.  If it is neither
@code{nil} nor 0, it asks the user whether to compile each file,
and asks about each subdirectory as well.

Interactively, @code{byte-recompile-directory} prompts for
@var{directory} and @var{flag} is the prefix argument.

If @var{force} is non-@code{nil}, this command recompiles every
@samp{.el} file that has a @samp{.elc} file.

The returned value is unpredictable.
@end deffn

@node byte-recompile-file
@subsection @code{byte-recompile-file}

@deffn Command byte-recompile-file filename &optional force arg load
@cindex library compilation

Recompile @var{filename} file if it needs recompilation.
This happens when its @samp{.elc} file is older than itself.

If the @samp{.elc} file exists and is up-to-date, normally this function
does not compile @var{filename}.  If the prefix argument @var{force} is non-nil,
however, it compiles @var{filename} even if the destination already
exists and is up-to-date.

If the @samp{.elc} file does not exist, normally this function *does not*
compile @var{filename}.  If optional argument ARG is 0, it compiles
the input file even if the @samp{.elc} file does not exist.
Any other non-nil value of @var{arg} means to ask the user.

If optional argument @var{load} is non-nil, loads the file after compiling.

If compilation is needed, this functions returns the result of
@code{byte-compile-file}; otherwise it returns @var{no-byte-compile}.
@end deffn

@node compile-defun
@subsection @code{compile-defun}
@deffn Command compile-defun &optional arg
This command reads the defun containing point, compiles it, and
evaluates the result.  If you use this on a defun that is actually a
function definition, the effect is to install a compiled version of that
function.

@code{compile-defun} normally displays the result of evaluation in the
echo area, but if @var{arg} is non-@code{nil}, it inserts the result
in the current buffer after the form it compiled.
@end deffn

@node disassemble
@subsection @code{disassemble}
@cindex disassembled byte-code

@deffn Command disassemble object &optional buffer-or-name
This command displays the disassembled code for @var{object}.  In
interactive use, or if @var{buffer-or-name} is @code{nil} or omitted,
the output goes in a buffer named @file{*Disassemble*}.  If
@var{buffer-or-name} is non-@code{nil}, it must be a buffer or the
name of an existing buffer.  Then the output goes there, at point, and
point is left before the output.

The argument @var{object} can be a function name, a lambda expression,
or a byte-code object (@pxref{Emacs Lisp Bytecode Objects}).  If it is a lambda
expression, @code{disassemble} compiles it and disassembles the
resulting compiled code.

There are a couple of variables that control how disassembly is displayed:

@multitable  @columnfractions .40 .20
@headitem
Variable Name
@tab
Default Value

@item @code{disassemble-column-1-indent}
@tab  @verb{| 8|}
@item @code{disassemble-column-2-indent}
@tab  @verb{|10|}
@item @code{disassemble-recursive-indent}
@tab  @verb{| 3|}
@end multitable

@end deffn

@node disassemble-file
@subsection @code{disassemble-file}

@deffn Command disassemble-file filename

The command is not part of GNU Emacs, but is included in an
experimental decompiler. It disassembles the entire contents of a bytecode
file using the @code{disassemble-full} for each function.
@end deffn

@node disassemble-full
@subsection @code{disassemble-full}

@deffn Command disassemble object &optional buffer-or-name indent

The command is not part of GNU Emacs, but is included in an
experimental decompiler. In contrast to the standard
@code{disassemble}, the format is slightly modified to make it easier to
decompile the code. For example, the full text of docstring is preserved and is
preceded by a length code of the string.

This functions prints disassembled code for @var{object} in
@var{buffer-or-name}.  @var{object} can be a symbol defined as a
function, or a function itself (a lambda expression or a
compiled-function object).  If @var{object} is not already compiled,
we compile it, but do not redefine @var{object} if it is a symbol."
@end deffn

@node display-call-tree
@subsection @code{display-call-tree}

Even though this is a command, it only has an effect when
@var{byte-compile-generate-call-tree} is set to non-nil; it is
@code{nil} by default. In this case, it is called when a file is byte
compiled, such as from @code{byte-compile-file}.

@deffn Command display-call-tree &optional filename
Display a call graph of a specified file.
This lists which functions have been called, what functions called
them, and what functions they call.  The list includes all functions
whose definitions have been compiled in this Emacs session, as well as
all functions called by those functions.

The call graph does not include macros, inline functions, or
primitives that the byte-code interpreter knows about directly,
e.g. @code{eq}, @code{cons}.

The call tree also lists those functions which are not known to be called
(that is, to which no calls have been compiled), and which cannot be
invoked interactively.
@end deffn

@node functionp
@subsection @code{functionp}

This is a general function, regarding functions in general.

@defun functionp object
Non-nil if @var{object} is a function.

Use this to see if a symbol is a function, that is something that can
be called. In most cases though @code{symbol-function} is more useful
as it not only distinguishes functions from non-functions, but can it
returns more information in those situations where @var{object} is a
function.
@end defun


@node make-byte-code
@subsection @code{make-byte-code}

@defun make-byte-code arglist byte-code constants depth &optional docstring interactive-spec &rest elements
Create a byte-code object with specified arguments as elements.
The arguments should be the @var{arglist}, bytecode-string @var{byte-code}, constant
vector @var{constants}, maximum stack size @var{depth}, (optional) @var{docstring},
and (optional) @var{interactive-spec}.

We briefly describe parameters below. For a more detailed discussion
of the parameters, @pxref{Emacs Lisp Bytecode Objects}.

The first four arguments are required; at most six have any
significance.  The @var{arglist} can be either like the one of
‘lambda’, in which case the arguments will be dynamically bound before
executing the bytecode, or it can be an integer of the form
@emph{NNNNNNNRMMMMMMM} where the 7bit @emph{MMMMMMM} specifies the
minimum number of arguments, the 7-bit @emph{NNNNNNN} specifies the
maximum number of arguments (ignoring @b{&rest}) and the @emph{R} bit
specifies whether there is a @b{&rest} argument to catch the left-over
arguments.  If such an integer is used, the arguments will not be
dynamically bound but will be instead pushed on the stack before
executing the byte-code.

There very little checking of the validity of the elements either at
creation time or at run time. If a parameter is are invalid or
inconsistent, Emacs may crash when you call the function.
@end defun

@b{Examples of calling @code{make-byte-code}}:
@findex make-byte-code

@example
@group

;; Null bytecode: no args, no bytecode, no stack needed
ELISP> (make-byte-code nil "" [] 0)

#[nil ""
    []
    0]

;; This byte-code for: '(lambda(a) (* a a ))
ELISP> (make-byte-code '(a) "^H211_\207" [a] 2)

#[(a)
  "^H211_\207"
  [a]
  2]

ELISP> (make-byte-code 1 2 3 4)

#[1 2 3 4]  ;; Doesn't even do type checking!

@end group
@end example

@node symbol-function-fn
@subsection @code{symbol-function}

This is a general function, but it has an interesting use in
conjunction with bytecode.

@defun symbol-function symbol

Return @var{symbol}’s function definition, or nil if that is void.

The value returned from @code{symbol-function} for a function will
when non-nil can be a number of things including:

@itemize
@item
its Lisp expression value (type cons node)
@item
its bytecode value (type compiled-function)
@item
its C function value (type subr)
@item
its Rust function value, if remacs
@item
an autoload function call.
@end itemize

For example if we take a function that is autoloaded when Emacs starts up:
@example
@group
ELISP> (symbol-function 'insert-file)

#[257 "\300^A301\"\207"
      [insert-file-1 insert-file-contents]
      4 2029839 "*fInsert file: "]
@end group
@end example

However if you load a file redefining the function, by loading in
emacs source, you get the last definition:

@example
@group
ELISP> (load-file "/usr/share/emacs/25.2/lisp/files.el.gz")

t
ELISP> (symbol-function 'insert-file)

(closure
  (backup-extract-version-start t)
  (filename)
  "Insert contents of file FILENAME into buffer after point.\nSet mark after the inserted text.\n\nThis function is meant for the user to run interactively.\nDon't call it from programs!  Use `insert-file-contents' instead.\n(Its calling sequence is different; see its documentation)."
  (interactive "*fInsert file: ")
  (insert-file-1 filename #'insert-file-contents))
@end group
@end example

Consider a function that hasn't been is set to be autoloaded:

@example
@group
    ELISP> (symbol-function 'ediff-buffers)

(autoload "ediff" 975154 t nil)
@end group
@end example

Finally, consider an interal function like @code{eolp}
@example
@group
    ELISP> (type-of (symbol-function 'eolp))
subr
@end group
@end example

@end defun

@include optimization.texi
