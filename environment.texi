@node Emacs Lisp Byte-Code Environment
@chapter Emacs Lisp Byte-Code Environment

In this chapter we will discuss the ways Emacs creates, modifies and
uses bytecode in order to run code. We describe a little of the two
kinds of interpreters Emacs has, what goes into a bytecode file, and
the interoperability of bytecode between versions.

@menu
* Byte-Code Objects::
* Byte-Code Compiler::
* Byte-Code Interpreter::
* Byte-Code Instructions::
* Byte-Code Files::
* Functions and Commands for working with Byte Code::
@end menu

@SECTION Byte-Code Objects

@emph{This section is largely lifted from Chris Wellons' Emacs byte
code Internals and the Emacs Lisp Reference manual. See references at
the end of this doc.}

Emacs Lisp bytecode isn't a low-level sequence of octets (bytes) that
requires a lot of additional special-purpose machinery to run.  There
is however custom C code interpreter to handle each of the instruction
primitives, and that is basically it. And even here, many of the
instructions are simply a bytecode form of some existing Emacs
primitive function like ``car'' or ``point''.

Emacs Lisp bytecode is a built-in Emacs Lisp type (same as a say a
Lisp ``cons'' node, or a Lisp symbol).

Functions @code{aref} and @code{mapcar} can be used extract the
components of bytecode once it is built, the bytecode object is made
up of other normal Emacs Lisp objects described next. Byte code is
created using the
@findex make-byte-code
@code{make-byte-code} function.

One important component of the bytecode object is the ``constants
vector.''  It contains important Lisp Objects that are required to
make sense of the bytecode-instruction operands: functions that share
the same bytecode-instruction byte string, but differ in their
constants vectors, can do very different things.

An Emacs Lisp object of a byte code type is analogous to an Emacs Lisp
vector. As with a vector, elements are accessed in constant time.

The print syntax of this type is similar to vector syntax, except
@verb{|#[...]|} is displayed to display a bytecode literal instead of
(@verb{|[...]|} as is used in a vector.

In contrast to vector object, there are no functions to index or extract
parts of a code object once it is build, and a byte-code object can be
evaluated as a function.  Valid byte-code objects have 4 to 6 elements
and each element has a particular structure elaborated on below.

There are two ways to create a byte-code object: using a byte-code
object literal or with @code{make-byte-code}. Like vector literals,
byte-code functions don't need to be quoted.

Examples of calling @code{make-byte-code}:
@findex make-byte-code
@verbatim
(make-byte-code 0 "" [] 0)
;; => #[0 "" [] 0]

#[1 2 3 4]
;; => #[1 2 3 4]

(#[0 "" [] 0])
;; error: Invalid byte opcode
@end verbatim

The elements of a bytecode function literal are:
@iftex
@enumerate
@item Function Parameter (lambda) List
@item Byte-code Unibyte String
@item Constants Vector
@item Maximum Stack Usage
@item Docstring
@item ``Interactive'' Specification
@end enumerate
@end iftex
@menu
* Function Parameter (lambda) List::
* Byte-code Unibyte String::
* Constants Vector::
* Maximum Stack Usage::
* Docstring::
* Interactive Specification::
@end menu

@node Function Parameter (lambda) List
@subsection Function Parameter (lambda) List

The first element of a bytecode-function literal is the parameter list
for the @code{lambda}. The object takes on two different forms
depending on whether the function is lexically or dynamically
scoped. If the function is dynamically scoped, the argument list is a
list and is exactly what appears in Lisp code. In this case, the
arguments will be dynamically bound befor executing the byte code.

@b{Example showing how a parameter list is transformed:}
@findex byte-compile
@verbatim
(setq lexical-binding nil) ; force lexical binding
(byte-compile
  (lambda (a b &optional c) 5))
;; => #[(a b &optional c) "\300\207" [5] 1]
@end verbatim

Above we show raw bytecode data. in Emacs after versions after 25
efforts have been made to hide the data.

There's really no shorter way to represent the parameter list because
preserving the argument names is critical. Remember that, in dynamic
scope, while the function body is being evaluated these variables are
globally bound (eww!) to the function's arguments.

On the other hand, when the function is lexically scoped, the
parameter list is packed into an Emacs Lisp integer, indicating the
counts of the different kinds of parameters: required,
@verb{|&optional|}, and @verb{|&rest|}. No variable names are
needed. Here in contrast to dynamically bound variables, the arguments
are onth the stack of the byte-code interperter before executing the
code

The following shows how parameter counts and flags are encoded:

@image{elisp-params-small,,,,.png}

The least significant 7 bits indicate the number of required
arguments. Notice that this limits compiled, lexically-scoped
functions to 127 required arguments. The 8th bit is the number of
&rest arguments (up to 1). The remaining bits indicate the total
number of optional and required arguments (not counting &rest). It's
really easy to parse these in your head when viewed as hexadecimal
because each portion almost always fits inside its own ``digit.''

@b{Example showing how lexical parameters are encoded:}
@findex byte-compile-make-args-desc
@verbatim
(byte-compile-make-args-desc '())
;; => #x000  (0 args, 0 rest, 0 required)

(byte-compile-make-args-desc '(a b))
;; => #x202  (2 args, 0 rest, 2 required)

(byte-compile-make-args-desc '(a b &optional c))
;; => #x302  (3 args, 0 rest, 2 required)

(byte-compile-make-args-desc '(a b &optional c &rest d))
;; => #x382  (3 args, 1 rest, 2 required)
@end verbatim

The names of the arguments don't matter in lexical scope: they're
purely positional. This tighter argument specification is one of the
reasons lexical scope is sometimes faster: the byte-code interpreter doesn't
need to parse the entire lambda list and assign all of the variables
on each function invocation; furthermore, variable access is via a
compact index located usually in the operand value rather than an
index into the constants vector followed by a lookup of the variable.

@node Byte-code Unibyte String
@subsection Byte-code Unibyte String

The second element of a bytecode-function literal is a unibyte string
--- it strictly holds octets and is not to be interpreted as any sort
of Unicode encoding. These strings should be created with
unibyte-string because string may return a multibyte string. To
disambiguate the string type to the lisp reader when higher values are
present (> 127), the strings are printed in an escaped octal notation,
keeping the string literal inside the ASCII character set.

@b{Example of a unibyte string:}
@verbatim
(unibyte-string 100 200 250)
;; => "d\310\372"
@end verbatim

It's unusual to see a byte-code string that doesn't end with 135
(#o207, return). Perhaps this should have been implicit? I'll talk
more about the byte code below.

@node Constants Vector
@subsection Constants Vector

The third object in a bytecode-function literal is a constants
vector. It's a normal Emacs Lisp vector and can be created with
@code{(vector ...)} or a vector literal.

In addition to the normal kinds of things one thinks of as constants
--- numbers, strings, and compositions of these --- the constants
vector importantly contains symbol constants of those dynamic
variables and function names which are referred to by the instructions
of the byte-code unibyte string.

The amount of space used by an Emacs byte-code instruction, and the
number of ways an operand in an instruction can refer to an Lisp
object is rather limited. Most operands are only a few bits in length,
some fill an entire byte, and occasionally an operand can be two bytes
in length. Given this, you can't have an arbitrary string or
structured Lisp object listed directly inside an operand. Instead,
operands reference either the constants vector or they index into the
evaluation stack itself.


@b{Example showing a constants vector}:
@verbatim
ELISP> (byte-compile
        (lambda (a b)
         (my-func '("hi" "there") a nil 5)))
#[(a b)
  "\301\302\303\304$\207"
  [a my-func
     ("hi" "there")
     nil 5]
  5]
@end verbatim

The above assumes that dynamic binding is in effect.

The constants vector in the above example contains 5 elements:
@itemize
@item @code{a} --- the symbol @code{a} which refers to a variable
@item @code{myfunc} the symbol @code{myfunc} which likely refers to an external function
@item @code{("hi" "there")} a list constant containing two strings
@item @code{nil} the nil constant
@item @code{5} the integer constant 5
@end itemize

The properties of symbol @code{a} and symbol @code{myfunc} are
consulted at run time, so as such there is no knowledge in the
bytecode representing the fact that @code{a} is a dynamically-bound
parmeter while @code{my-func} is probably an external function.

If the lambda were a lexically-scoped, the constants vector would not
have the variable symbol @code{a} listed, but instead there would be a
stack entry.

Note that although the symbol @code{b} is a parameter of the lambda,
it doesn't appear in the constants vector, since it is not used in the
body of the function.

@node Maximum Stack Usage
@subsection Maximum Stack Usage

The fourth object in a bytecode-function literal is an integer which gives
the maximum stack space used by this byte-code. This value can be
derived from the byte code itself, but it's pre-computed so that the
byte-code interpreter can quickly check for stack
overflow. Under-reporting this value is probably another way to crash
Emacs.

In our example above, maximum-stack value is five since function
@code{myfunc} is called with four parameters which are pushed onto the
stack, and there is an additional stack entry pushed the @code{myfunc}
symbol itself. All of this needs to be in place on the stack just
before a @code{call} instruction runs to perform the @code{myfunc}
call.

@node Docstring
@subsection Docstring

The fifth object in a bytecode-function literal is simple and
completely optional. Depending on how the function was created the
docstring is either the docstring, or a cons cell indicating a
compiled `.elc` and a position for lazy access. Only one position, the
start, is needed because the lisp reader is used to load it and it
knows how to recognize the end.

@node Interactive Specification
@subsection ``Interactive'' Specification

When there is a sixth field in the bytecode-function the function is a
command, i.e an ``interative'' function.  Otherwise the function is
not a command.  That parameter holds the exactly contents of the
argument to @code{interactive} in the uncompiled function definition.
Note that @code{(interactive)} causes the sixth field to be nil,
which is distinct from there not being a sixth feild.

@b{Examples showing the interactive specification:}
@verbatim
ELISP> (byte-compile
         (lambda (n)
           (interactive "nNumber: ") n))
;; => #[(n) "\010\207" [n] 1 nil "nNumber: "]

ELISP> (byte-compile
         (lambda (n)
          (interactive (list (read))) n))
;; => #[(n) "\010\207" [n] 1 nil (list (read))]
@end verbatim

The interactive expression usually interpreted, which is fine because,
by definition, this code is going to be waiting on user
input. However, it slows down keyboard macro playback.


@SECTION Byte-Code Compiler

The Byte-Code compiler is an ahead-of-time compiler that
accepts Emacs Lisp input and produces bytecode that can be run by
Emacs. The compiler itself is written in Emacs Lisp @footnote{usually,
the compiler itself is compiled into bytecode, which avoids overflow
problems}, and is a comparatively compact program contained in the
files @code{bytecomp.el} and @code{byte-opt.el}.

Internally, the compiler first produces an intermediate Lisp structure
in LAP code, then performs various optimizations on that, and finally
translates the LAP code into bytecode. LAP code is used during
compilation, but not kept in memory or used when running bytecode.

It is possible to go back to LAP code from bytecode; this is done in
order to inline functions and when bytecode disassembly is requested.

@SECTION Byte-Code Interpreter

When a function is called and the function is represented as bytecode,
control passes to the bytecode interpreter.  The interpreter is
written in C and is written more for speed than readability.

The bytecode interpreter operates on a single function at a time; for
a function call, the bytecode interpreter calls other parts of Emacs,
which might call the bytecode interpreter again, recursively. Thus, in
contrast to languages like FORTH, there is no code stack per se, just
the C stack.

The bytecode interpreter implements a stack machine utilizing a
fixed-size evaluation stack, which is usually allocated as a block on
the C stack. Instructions can access either this stack or a constants
vector, which is produced at compile time and made part of the
bytecode object.

The evaluation stack, as well as the constants vector, contains Lisp
values, usually 64-bit words containing an integer (Emacs integers are
limited to 62 bits on 64-bit machines), symbol index, or a tagged
pointer to one of various Emacs structures such as markers, buffers,
floating-point numbers, vectors, or cons cells.

Values on the evaluation stack are created at run time; values in the
constants vector are created when the byte-compiled file is read and
converted into bytecode objects. The underlying bit representation of
values in the constants vector can vary between Emacs instances: they
are constants in the sense that they do not vary within a single Emacs
instance.

Bytecode objects contain a number safely estimating the maximum stack
size the evaluation stack can grow to.

@SECTION Byte-Code Instructions

The bytecode interpreter, once it has set up the evaluation stack and
constants vector, executes the instructions that make up the bytecode
byte string: each instruction is between one and three bytes in
length, containing an opcode in the first byte and sometimes an eight-
or 16-bit integer in the following bytes. Those integers are usually
unsigned, and 16-bit integers are stored in little-endian byte order,
regardless of whether that is the natural byte order for the machine
Emacs runs on.

Some opcodes, allocated in blocks, encode an integer as part of the
opcode byte.

Bytecode instructions operate on the evaluation stack: for example,
@code{plus}, the addition function, removes two values from the
top of the stack and pushes a single value, the sum of the first two
values, back on the stack.

Since the arguments for a function call need to be on the stack before
the function can operate on them, bytecode instructions use Reverse
Polish Notation: first the arguments are pushed on the stack, then the
function or operation is called.  For example, the Lisp expression
@code{(+ a b)} turns into this bytecode:

@c @code{(defun plus (a b) (+ a b))} generates
@verbatim
PC  Byte  Instruction
 0    8   varref a
 1    9   varref b
 2   92   plus
@end verbatim

First @code{a} and @code{b} are dereferenced and their values pushed
onto the evaluation stack; then @code{plus} is executed, leaving
only a single value, the sum of @code{a} and @code{b}, on the stack.

@SECTION Byte-Code Files

When Emacs is build from source code, there is C code for some
primitive or built-in functions. These include Lisp functions like
@code{car}, or primitive Emacs functions like @code{point}. Other
equally important functions are implemented in Emacs Lisp.  These are
byte compiled and then loaded into Emacs. On many systems there is the
ability to dump Emacs in some kind of image format after these basic
functions have been loaded. But even if that doesn't happen, a file
called @code{loaddefs.el} is created that contains many of the
important basic primitive functions as bytecode.

When you invoke Emacs then, it has a number of functions already
loaded and these are either coded in C or have been byte compiled and
loaded. Before running a function, Emacs queries the type of code that
is associated with the function symbol and calls either its lambda
S-expression interpreter or its bytecode interpreter.

When you run @code{load}, which reads and evaluates Lisp code from a
file, at the top-level it doesn't matter whether the file contains
bytecode or Emacs Lisp source code. Either way the only thing done is
to open the file, and read the contents of the file using the normal
Lisp reader. The difference between the two kinds of files is more
about convention than it is strictly about the contents of the file.

The difference between a Emacs Lisp bytecode file and a Emacs Lisp
source file, then is two things. First the bytecode file will have a
comment header in it that starts @verb{|;ELC^W^@^@^@|} while the
source code probably doesn't. (However there's nothing to stop you
from adding in that line if you feel like it). In addition to this
comment header, a bytecode file will have other meta-comments such as
which version of Emacs was used to compile the file and whether
optimization was used. In earlier versions, there was information
about the program that was used to compile the program was given, like
its version number. And the source code path used to be in there as
well. (I think these things should still be in there but that's a
different story).  @xref{Instruction Changes Between Emacs Releases} where
we give examples of the headers to show how that has changed.

The second thing that is typically different between source code files
and bytecode files is the prevalence of the @code{byte-code} calls
used in the file and with the inclusion of those comes a lack of any
@code{defun}, @code{defmacro}, or @code{lambda} calls. But again I
suppose there's nothing stopping you from using doing likewise in your
source code.

In fact, you can take a file with the @code{.elc} extension, rename it
to have an @code{.el} extension instead and @code{load} that. And that
will run exactly the same if it had been loaded as a byte code
file@footnote{If you go the other direction and rename a Lisp file as
a bytecode file, Emacs will notice the discrepency because at the top
of the file is a header that Emacs checks. But if you add a
reasonable-looking header you can go that direction as well.}.

Similarly, just as you can concatenate any number of independent Emacs
Lisp source code files into one file@footnote{and this is sometimes
done as a poor-man's way to create a package}, you can do the same
with Emacs Lisp bytecode files.

Of course, there will probably certain programs that are fooled when
the extension is changed. In particular, the
@code{byte-recompile-directory} function it will think that the
bytecode file doesn't exist because it has the wrong extension. So
even though Emacs is permissive about such matters, it is best to
stick with the normal Emacs conventions.

The final thing that should be mentioned when talking about bytecode
files is interoperability between Emacs versions.

Even though a bytecode header has a meta comment indicating the
version of Emacs that was used to compile it, that information is not
used in determining whether the bytecode file can be run or not.

This has the benefit of being able to run bytecode compiled in
different Emacs version than the version you are currently
running. Since Emacs bytecode instructions do not change that often,
this largely works. The scary part though is that opcode meanings have
changed over the 30 years, and the interpreter is and has been
sometimes lacking in checks. (In the past the interpreter has aborted
when running an invalid bytecode). So Emacs doesn't even know that you
are running bytecode from a different interpreter. There is no check
that you aren't going off a cliff running older or newer bytecode.

However, Emacs developer(s) maintain that in practice problems haven't
occurred with such frequency that it has been reported happened enough
to be a problem.  Also, they try to keep backward compatability
between versions. In other words, bytecode that was generated in an
older version of Emacs but is no longer generated will often still be
interpreted in the new version of Emacs. While this is a nice
intention, the facts seem to suggest that this isn't always the
case. (Nor could it be in reality for a program that is 30 years old
or so).

@xref{Instruction Changes Between Emacs Releases} then for when this is
likely to work and in what cases it won't. And although running newer
bytecode in an older version of Emacs isn't explicitly considered,
again, since bytecode doesn't change that often, in reality this too
can sometimes work out.

Note that this is in sharp contrast other bytecode interpreters like
Python where the magic used in compiling has to be the same as the
value of running interpreter or Python will refuse to run.

Personally, I think it would be nice to have a Emacs Lisp bytecode
checker, perhaps a @code{safer-load} function that does look at the
bytecode and its meta-comments gleans when there is something that is
known to cause problems. Any volunteers?

@SECTION Functions and Commands for working with Byte Code

@menu
* batch-byte-compile::
* batch-byte-recompile-directory::
* byte-compile::
* byte-compile-file::
* byte-recompile-directory::
* byte-recompile-file::
* compile-defun::
* disassemble::
* display-call-tree::
* make-byte-code::
@end menu

@node batch-byte-compile
@subsection @code{batch-byte-compile}

@defun batch-byte-compile &optional noforce
This function runs @code{byte-compile-file} on files specified on the
command line.  This function must be used only in a batch execution of
Emacs, as it kills Emacs on completion.  An error in one file does not
prevent processing of subsequent files, but no output file will be
generated for it, and the Emacs process will terminate with a nonzero
status code.

If @var{noforce} is non-@code{nil}, this function does not recompile
files that have an up-to-date @samp{.elc} file.

@example
$ emacs -batch -f batch-byte-compile *.el
@end example
@end defun

@node batch-byte-recompile-directory
@subsection @code{batch-byte-recompile-directory}

@defun batch-byte-recompile-directory directory &optional arg
Run @code{byte-recompile-directory} on the dirs remaining on the command line.
Must be used only with @code{-batch}, and kills Emacs on completion.
For example, invoke @code{emacs -batch -f batch-byte-recompile-directory .}.

Optional argument @var{arg} is passed as second argument @var{arg} to
@code{byte-recompile-directory}; see there for its possible values
and corresponding effects.
@end defun

@node byte-compile
@subsection @code{byte-compile}

@deffn Command byte-compile form
If @var{form} is a symbol, byte-compile its function definition.
If @var{form} is a lambda or a macro, byte-compile it as a function.
@end deffn

@node byte-compile-file
@subsection @code{byte-compile-file}

@deffn Command byte-compile-file filename &optional load
This function compiles a file of Lisp code named @var{filename} into a
file of byte-code.  The output file's name is made by changing the
@samp{.el} suffix into @samp{.elc}; if @var{filename} does not end in
@samp{.el}, it adds @samp{.elc} to the end of @var{filename}.

Compilation works by reading the input file one form at a time.  If it
is a definition of a function or macro, the compiled function or macro
definition is written out.  Other forms are batched together, then each
batch is compiled, and written so that its compiled code will be
executed when the file is read.  All comments are discarded when the
input file is read.

This command returns @code{t} if there were no errors and @code{nil}
otherwise.  When called interactively, it prompts for the file name.

If @var{load} is non-@code{nil}, this command loads the compiled file
after compiling it.  Interactively, @var{load} is the prefix argument.

@example
@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
@end group

@group
(byte-compile-file "~/emacs/push.el")
     @result{} t
@end group

@group
$ ls -l push*
-rw-r--r-- 1 lewis lewis 791 Oct  5 20:31 push.el
-rw-rw-rw- 1 lewis lewis 638 Oct  8 20:25 push.elc
@end group
@end example
@end deffn

@node byte-recompile-directory
@subsection @code{byte-recompile-directory}

@deffn Command byte-recompile-directory directory &optional flag force
@cindex library compilation
This command recompiles every @samp{.el} file in @var{directory} (or
its subdirectories) that needs recompilation.  A file needs
recompilation if a @samp{.elc} file exists but is older than the
@samp{.el} file.

When a @samp{.el} file has no corresponding @samp{.elc} file,
@var{flag} says what to do.  If it is @code{nil}, this command ignores
these files.  If @var{flag} is 0, it compiles them.  If it is neither
@code{nil} nor 0, it asks the user whether to compile each such file,
and asks about each subdirectory as well.

Interactively, @code{byte-recompile-directory} prompts for
@var{directory} and @var{flag} is the prefix argument.

If @var{force} is non-@code{nil}, this command recompiles every
@samp{.el} file that has a @samp{.elc} file.

The returned value is unpredictable.
@end deffn

@node byte-recompile-file
@subsection @code{byte-recompile-file}

@deffn Command byte-recompile-file filename &optional force arg load
@cindex library compilation

Recompile @var{filename} file if it needs recompilation.
This happens when its @samp{.elc} file is older than itself.

If the @samp{.elc} file exists and is up-to-date, normally this function
@emph{does not} compile @var{filename}.  If the prefix argument @var{force} is non-nil,
however, it compiles @var{filename} even if the destination already
exists and is up-to-date.

If the @samp{.elc} file does not exist, normally this function *does not*
compile @var{filename}.  If optional argument ARG is 0, it compiles
the input file even if the @samp{.elc} file does not exist.
Any other non-nil value of @var{arg} means to ask the user.

If optional argument @var{load} is non-nil, loads the file after compiling.

If compilation is needed, this functions returns the result of
@code{byte-compile-file}; otherwise it returns @var{no-byte-compile}.
@end deffn

@node compile-defun
@subsection @code{compile-defun}
@deffn Command compile-defun &optional arg
This command reads the defun containing point, compiles it, and
evaluates the result.  If you use this on a defun that is actually a
function definition, the effect is to install a compiled version of that
function.

@code{compile-defun} normally displays the result of evaluation in the
echo area, but if @var{arg} is non-@code{nil}, it inserts the result
in the current buffer after the form it compiled.
@end deffn

@node disassemble
@subsection @code{disassemble}
@cindex disassembled byte-code

@deffn Command disassemble object &optional buffer-or-name
This command displays the disassembled code for @var{object}.  In
interactive use, or if @var{buffer-or-name} is @code{nil} or omitted,
the output goes in a buffer named @file{*Disassemble*}.  If
@var{buffer-or-name} is non-@code{nil}, it must be a buffer or the
name of an existing buffer.  Then the output goes there, at point, and
point is left before the output.

The argument @var{object} can be a function name, a lambda expression,
or a byte-code object (@pxref{Byte-Code Objects}).  If it is a lambda
expression, @code{disassemble} compiles it and disassembles the
resulting compiled code.
@end deffn

@node display-call-tree
@subsection @code{display-call-tree}

@deffn Command display-call-tree &optional filename
Display a call graph of a specified file.
This lists which functions have been called, what functions called
them, and what functions they call.  The list includes all functions
whose definitions have been compiled in this Emacs session, as well as
all functions called by those functions.

The call graph does not include macros, inline functions, or
primitives that the byte-code interpreter knows about directly,
e.g. @code{eq}, @code{cons}.

The call tree also lists those functions which are not known to be called
(that is, to which no calls have been compiled), and which cannot be
invoked interactively.
@end deffn

@node make-byte-code
@subsection @code{make-byte-code}

@defun make-byte-code arglist byte-code constants depth &optional docstring interactive-spec &rest elements
Create a byte-code object with specified arguments as elements.
The arguments should be the @var{arglist}, bytecode-string @var{byte-code}, constant
vector @var{constants}, maximum stack size @var{depth}, (optional) @var{docstring},
and (optional) @var{interactive-spec}.

The first four arguments are required; at most six have any
significance.  The @var{arglist} can be either like the one of
‘lambda’, in which case the arguments will be dynamically bound before
executing the byte code, or it can be an integer of the form
@emph{NNNNNNNRMMMMMMM} where the 7bit @emph{MMMMMMM} specifies the
minimum number of arguments, the 7-bit @emph{NNNNNNN} specifies the
maximum number of arguments (ignoring &rest) and the R bit specifies
whether there is a &rest argument to catch the left-over arguments.
If such an integer is used, the arguments will not be dynamically
bound but will be instead pushed on the stack before executing the
byte-code.

There very little checking of the validity of the elements either at
creation time or at run time. If a parameter is are invalid or
inconsistent, Emacs may crash when you call the function.
@end defun
