@node ELisp Bytecode Instructions
@chapter ELisp Bytecode Instructions


@menu
* Instruction-Description Format::
* Argument-Packing Instructions::
* Constants-Vector Retrieval Instructions::
* Exception-Handling Instructions::
* Control-Flow Instructions::
* Function-Call Instructions::
* Stack Manipulation Instructions::
* Binding Instructions::
@end menu

@node Instruction-Description Format
@section Instruction-Description Format

In this chapter we'll document instructions over the course of the
entire history of Emacs. Or at least we aim to.

For the opcode names, we will prefer canonicalized names from the
Emacs C source @code{bytecode.c} (under directory @code{src/}) when
those differ from the names in @code{bytecomp.el} (under directory
@code{lisp/emacs-lisp}). Names in @code{bytecode.c} follow C
conventions and must be adjusted to harmonize with other C names used,
and this aspect isn't of use here. So we canonicalize those aspects
away.

For example, in @code{bytecode.c} there is an opcode whose name is
@code{Bbuffer_substring}. We will drop the initial @code{B} and
replace all underscores (@verb{|_|}) with dashes
(@verb{|-|}). Therefore this name appears below as
@code{buffer-substring} here.

The corresponding name for that opcode in @code{bytecomp.el} is
@code{byte-buffer-substring}.  For the most part, if you drop the
initial @code{byte-} prefix in the @code{bytecomp.el} name you will
often get the canonic name from @code{bytecode.c}. However this isn't
always true.

In particular, consider opcodes 97 and 114; 97 became obsolete in
Emacs 24.1 but implemented some kind of @code{save-current-buffer}
instruction. Opcode 97 was then reused. When the
@code{save-current-buffer} instruction was reintroduced, it got added
as opcode 114. In @code{bytecomp.el} only the name
@code{byte-save-current-buffer} appears, while in the C code the name
@code{B_save_current_buffer} is used for opcode 97 and
@code{B_save_current_buffer_1} is used for opcode 114.  And that is
why we go with the @code{bytecode.c} name.  The names we use are
@code{save-current-buffer} and @code{save-current-buffer-1}.

To shorten and regularize instruction descriptions, each instruction
is described a standard format. We will also require a small
amount of jargon. This jargon are explained below.


@subsection Instruction Jargon
@itemize
@item @code{TOS}
The value of top of the evaluation stack. Many instructions either read or push onto this.
@item @code{S}
This is an array of evaluation stack items. @code{S[0]} is the top of the stack, or
@code{TOS}.
@item @code{top}
A pointer to the the top of the evaluation stack. In C this would be
@code{&TOS}. When we want the stack to increase in size, we add to
top. For example, to makes space to store a new single new value, we
can use @code{top++} and then assign to @code{TOS}.

Note that in changing @code{top}, the value accessed by @code{TOS} or
@code{S} values all change.
@item @math{\phi}
This is used in describing stack effects for branching instructions
where the stack effect is different on one branch versus the
other. This is a function of two arguments. The first argument gives
the stack effect on the non-nil branch and the second argument gives
the stack effect for the nil branch. So @math{\phi(0,-1)} which is
seen in @code{goto-if-not-nil-else-pop} means that if the jump is
taken, the stack effect is 0, otherwise the effect removes or pops an
evaluation-stack entry.
@item opcode subscripting (@code{[]})
In many instructions such as @code{constant}, @code{varref}, you will
find an index after the opcode. What's going on is that opcode name is
one of a number of opcodes in a class encodes an index into the
instruction. We generally call this an ``Argument-encoding''
instruction. In the display of the opcode in assembly listings and in
the opcode table chapter where we list each opcode, we will include
that particular instruction variant in subscripts.

For example consider @code{constant[0]} versus @code{constant[1]}.
The former has opcode 192 while the latter has opcode 193. In terms of
semantics, the former is the first or zeroth-index entry in a function's constant
vector while the latter is the second or 1-index entry.

@end itemize

@subsection Instruction Description Fields
The description of fields use for describing each instruction is as follows
@table @strong
@item Implements:
A description of what the instruction does.
@item Generated via:
These give some ELisp constructs that may generate the instruction. Of
course there may be many constructs and there may be limiting
situations within that construct. We'll only give one or a few of the
constructs, and we'll try to indicate a limiting condition where
possible.
@item Operand:
When an instruction has an operand, this descripts the type of the
operand.  Note that the size of the operand (or in some cases the
operand value) will determine the instruction size.
@item Instruction size:
The number of bytes in the instruction. This is 1 to 3 bytes.
@item Stack effect:
This describes how many stack entries are read and popped and how many
entries stack entries are pushed. Although this is logically a tuple,
we'll list this a tuple like @math{(-3, 2)} as a single scalar
@math{-3+2}. In this example, we read/remove three stack entries and
add two.  The reason we give this as @math{-3+2} rather than the tuple
format is so that the overall effect (removing a stack entry) can be
seen by evaluating the expression.
@item Added in:
This is optional. When it is given this gives which version of Emacs
the opcode was added. It may also give when the opcode became obsolete
or was no longer implemented.
@item Example:
Some ELisp code to show how the instruction is used. For example
the for the @code{goto} instruction we give:

@verbatim
(defun goto-eg(n)
  (while (n) 1300))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  133   goto-if-nil-else-pop [8]
           8
           0
 5  130   goto [0]
           0
           0
 8  135   return

Constants Vector: [n]
@end verbatim

From the above we see that the @code{goto} instruction at program
counter (PC) 5, has decimal opcode 130. The instruction is three bytes
long: a one-byte opcode followed by a two-byte operand.

Unless otherwise stated, all code examples were compiled in Emacs 25
with optimization turned off.
@end table

@page
@node Argument-Packing Instructions
@section Argument-Packing Instructions

These instructions from opcode 1 to 47 encode an operand value from 0
to 7 encoded into the first byte.  If the encoded value is 6, the actual
operand value is the byte following the opcode.  If the encoded value
is 7, the actual operand value is the two-byte number following the
opcode, in Little-Endian byte order.

@menu
* stack-ref::
* varref::
* varset::
* varbind::
* call::
* unbind::
@end menu

@node stack-ref
@unnumberedsubsec @code{stack-ref} (1--7)
@kindex stack-ref

Reference a value from the evaluation stack.

@table @strong
@item Implements:
@code{top++; TOS <- S[i+1]} where @code{i} is the value of the
instruction operand.
@item Generated via:
@code{let}, @code{let*} and lambda arguments.
@item Operand:
A stack index
@item Instruction size:
1 byte for @code{stack-ref[0]} .. @code{stack-ref[4]}; 2 bytes for @code{stack-ref[5]}, 8-bit operand;
3 bytes for @code{stack-ref[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Added in:
Added in Emacs 24.1
@item Example:
When lexical binding is in effect,
@verbatim
(defun stack-ref-eg()
  (let ((a 5) (_b 6) (c 7))
    (+ a c)))}
@end verbatim
generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 5
 1  193   constant[1] 6
 2  194   constant[2] 7
 3    2   stack-ref[2]  ;; top++; TOS <- S[3]
 4    1   stack-ref[1]  ;; top++; TOS <- S[2]
 5   92   plus
 6  178   stack-set [3] ;; Set return value, S[2]
          3             ;; before discarding stack entries
 8  136   discard
 9  136   discard
10  135   return

Constants Vector: [5 6 7]
@end verbatim
@end table

@strong{Warning}
Running an instruction with opcode 0 (logically this would be called
@code{stack-ref[0]}), will cause an immediate abort of Emacs in
versions after version 20 and before version 25! The abort of the
opcode was in place before this instruction was added.

Zero is typically an invalid in bytecode and in machine code, since
zero values are commonly found data, e.g. the end of C strings, or
data that has been initialized to value but represents data that
hasn't been written to yet. By having it be an invalid instruction, it
is more likely to catch situations where random sections of memory are
run such as by setting the PC incorrectly.


@node varref
@unnumberedsubsec @code{varref} (8--15)

Pushes the value of the symbol in the constants vector onto the
evaluation stack.

@kindex varref
@table @strong
@item Implements:
@code{top++; TOS <- (eval constants_vector[i])} where @code{i} is the
value of instruction operand
@item Generated via:
dynamic variable access
@item Operand:
A constants vector index. The constants vector item should be a variable symbol.
@item Instruction size:
1 byte for @code{varref[0]} .. @code{varref[4]}; 2 bytes for @code{varref[5]},
8-bit operand; 3 bytes for @code{varref[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Example:
When dynamic binding is in effect,
@verbatim
(defun varref-eg(n)
  n)
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] n
 1  135   return

Constants Vector: [n]
@end verbatim
@end table

@node varset
@unnumberedsubsec @code{varset} (16--23)

Sets a variable listed in the constants vector to the TOS value
of the stack.

@kindex varset
@table @strong
@item Implements:
@code{constants_vector[i] <- TOS; top--} where @code{i} is the value of the
instruction operand.
@item Operand:
A constants vector index. The constants vector item should be a variable symbol.
@item Instruction size:
1 byte for @code{varset[0]} .. @code{varset[4]}; 2 bytes for @code{varset[5]},
8-bit operand; 3 bytes for @code{varset[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Example:
When dynamic binding is in effect,
@verbatim
defun varset(n)
  (setq n 5))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] 5
 1  137   dup
 2   16   varset[0] n ;; sets variable n
 3  135   return

Constants Vector: [n 5]
@end verbatim
@end table

@node varbind
@unnumberedsubsec @code{varbind} (24--31)
@kindex varbind

Binds a variable to a symbol in the constants vector, and adds the
symbol to a special-bindings stack.

@table @strong
@item Implements:
@code{(set_internal(constants_vector[i])} where @code{i} is the value of the
instruction operand.
@item Instruction size:
1 byte for @code{varset[0]} .. @code{varset[4]}; 2 bytes for @code{varset[5]},
8-bit operand; 3 bytes for @code{varset[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Example:
When dynamic binding is in effect,
@verbatim
defun varbind-eg()
  (let ((c 1))
    (1+ c)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] 1
 1  137   dup
 2   24   varbind[0] c ;; creates variable c
 3   84   add1
 4   41   unbind[1]    ;; removes variable c
 5  135   return

Constants Vector: [c 1]
@end verbatim
@end table

@node call
@unnumberedsubsec @code{call} (32--39)
@kindex call

Calls a function.  The instruction argument specifies the number of
arguments to pass to the function from the stack, excluding the
function itself.

@table @strong
@item Implements:
@code{(set_internal(constants_vector[i])} where @code{i} is the value of the
instruction operand.
@item Instruction size:
1 byte for @code{varset[0]} .. @code{varset[4]}; 2 bytes for @code{varset[5]},
8-bit operand; 3 bytes for @code{varset[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Example:
@verbatim
(defun call-eg()
  (exchange-point-and-mark)
  (next-line 2))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] exchange-point-and-mark
 1   32   call[0]
 2  136   discard
 3  193   constant[1] next-line
 4  194   constant[2] 2
 5   33   call[1]
 6  135   return

Constants Vector: [exchange-point-and-mark next-line 2]
@end verbatim
@end table

@node unbind
@unnumberedsubsec @code{unbind} (40--47)
@kindex unbind

Remove the binding of a variable to symbol and from the special
stack. This is done when the variable is no longer needed.

@table @strong
@item Implements:
@code{(set_internal(constants_vector[i])}
@item Instruction size:
1 byte for @code{varset[0]} .. @code{varset[4]}; 2 bytes for @code{varset[5]},
8-bit operand; 3 bytes for @code{varset[6]}, 16-bit operand.
@item Stack effect:
@math{-0+1}.
@item Example:
When dynamic binding is in effect,
@verbatim
defun varbind-eg()
  (let ((c 1))
    (1+ c)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] 1
 1  137   dup
 2   24   varbind[0] c ;; creates variable c
 3   84   add1
 4   41   unbind[1]    ;; removes variable c
 5  135   return

Constants Vector: [c 1]
@end verbatim
@end table


@node Constants-Vector Retrieval Instructions
@section Constants-Vector Retrieval Instructions

The instructions from opcode 192 to 255 push a value from the
Constants Vector. @xref{Constants Vector}. Opcode 192 pushes the first
entry, opcode 193, the second and so on. If there are more than 64
constants, opcode @code{constant2} (opcode 129) is used instead.

@menu
* constant::
* constant2::
@end menu

@node constant
@unnumberedsubsec @code{constant} (192--255)
@kindex constant

Pushes a value from the constants vector on the evaluation stack.
There are special instructions to push any one of the first
64 entries in the constants stack.

@table @strong
@item Implements:
@code{top++; TOS <- constants_vector[i]}  where @code{i} is the value of the
instruction operand.
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+1}.
@item Added in:
Emacs 25.1
@item Example:
@verbatim
defun n3(n)
  (+ n 10 11 12))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] +
 1    8   varref[0] n
 2  194   constant[2] 10
 3  195   constant[3] 11
 4  196   constant[4] 12
 5   36   call[4]
 6  135   return

Constants Vector: [n + 10 11 12]
@end verbatim
@end table

@node constant2
@unnumberedsubsec @code{constant2} (129)
@kindex constant2

Pushes a value from the constants vector on the evaluation stack.
Although there are special instructions to push any one of the first
64 entries in the constants stack, this instruction is needed to push
a value beyond one the first 64 entries.

@table @strong
@item Implements:
@code{top++; TOS <- constants_vector[i]} where @code{i} is the value of the
instruction operand.
@item Operand:
a 16-bit index into the constants vector.
@item Instruction size:
3 bytes
@item Stack effect:
@math{-0+1}.
@item Example:
@c @code{(defun n64 (n) (+ n 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64))} generates
@c ((optimize . nil))

@verbatim
(defun n64(n)
 (+ n 0 1 2 3 .. 64))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  193   constant[1] +
 1    8   varref[0] n
 2  194   constant[2] 0
 3  195   constant[3] 1
 4  196   constant[4] 2
[...]
63  255   constant[63] 61
64  129   constant2 [64] 62
          64
           0
67  129   constant2 [65] 63
          65
           0
70  129   constant2 [66] 64
          66
           0
73   38   call [66]
          66
75  135   return

Constants Vector: [n + 0 1 2 .. 61 62 63 64]
@end verbatim
@end table

@page
@node Exception-Handling Instructions
@section Exception-Handling Instructions

@menu
* pophandler::
* conditioncase::
* pushconditioncase::
@end menu

@node pophandler
@unnumberedsubsec @code{pophandler} (48)
@kindex pophandler

@table @strong
@item Implements:
Removes last condition pushed by @code{pushconditioncase}
@item Generated via:
@code{condition-case}
@item Instruction size:
1 byte
@item Stack effect:
@math{-0+0}.
@item Added in:
Emacs 24.4
@item Example:
@verbatim
(defun pushconditioncase-eg()
  (condition-case nil
    5
    (one-error 6)
    (another-error 7)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (another-error)
 1   49   pushconditioncase [16]
          16
           0
 4  193   constant[1] (one-error)
 5   49   pushconditioncase [12]
          12
           0
 8  194   constant[2] 5
 9   48   pophandler
10   48   pophandler
11  135   return
12   48   pophandler
13  136   discard
14  195   constant[3] 6
15  135   return
16  136   discard
17  196   constant[4] 7
18  135   return

Constants Vector: [(another-error) (one-error) 5 6 7]
@end verbatim

@end table

@node conditioncase
@unnumberedsubsec @code{conditioncase} (49)
@kindex conditioncase

@table @strong
@item Implements:
?
@item Instruction size:
3 bytes ?
@item Stack effect:
@math{-0+0}.
@item Added in:
Emacs 24.4
@item Example:
?
@end table

@node pushconditioncase
@unnumberedsubsec @code{pushconditioncase} (50)
@kindex pushconditioncase

@table @strong
@item Implements:
Pops the TOS which is some sort of condition to test on and
registers that. If any of the instructions errors with that condition,
a jump to the operand occurs.
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-1+0}.
@item Added in:
Emacs 24.4
@item Example:
@verbatim
(defun pushconditioncase-eg()
  (condition-case nil
    5
    (one-error 6)
    (another-error 7)))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (another-error)
 1   49   pushconditioncase [16]
          16
           0
 4  193   constant[1] (one-error)
 5   49   pushconditioncase [12]
          12
           0
 8  194   constant[2] 5
 9   48   pophandler
10   48   pophandler
11  135   return
12   48   pophandler
13  136   discard
14  195   constant[3] 6
15  135   return
16  136   discard
17  196   constant[4] 7
18  135   return

Constants Vector: [(another-error) (one-error) 5 6 7]
@end verbatim
@end table

@node Control-Flow Instructions
@section Control-Flow Instructions

@menu
* goto::
* goto-if-nil::
* goto-if-not-nil::
* goto-if-nil-else-pop::
* goto-if-not-nil-else-pop::
* return::
@end menu

@node goto
@unnumberedsubsec @code{goto} (130)
@kindex goto
@table @strong
@item Implements:
Jump to label given in the 16-bit operand
@item Generated via:
@code{while} and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-0+0}
@item Example:
@code{(defun goto-eg(n) (while (n) 1300))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  133   goto-if-nil-else-pop [8]
           8
           0
 5  130   goto [0]
           0
           0
 8  135   return

Constants Vector: [n]
@end verbatim

@end table

@node goto-if-nil
@unnumberedsubsec @code{goto-if-nil} (131)
@kindex goto-if-not-nil
@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is nil. In contrast to
@code{goto-if-nil-else-pop}, the test expression, TOS, is always popped.
@item Generated via:
@code{if} with ``else'' clause and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-1+0}
@item Example:
@code{(defun goto-if-nil-eg(n) (if (n) 1310 1311))} generates:
@c ((optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  131   goto-if-nil [9]
           9
           0
 5  193   constant[1] 1310
 6  130   goto [10]
          10
           0
 9  194   constant[2] 1311
10  135   return

Constants Vector: [n 1310 1311]
@end verbatim

@end table

@node goto-if-not-nil
@unnumberedsubsec @code{goto-if-not-nil} (132)
@kindex goto-if-not-nil
@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is not nil.  In
contrast to @code{goto-if-not-nil-else-pop}, the test expression, TOS, is
always popped.
@item Generated via:
@code{or} inside an @code{if} with optimization and various
control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{-1+0}
@item Example:
With bytecode optimization, @code{(defun goto-if-not-nil-eg(n) (if (or (n) (n)) 1320))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  132   goto-if-not-nil [10]
          10
           0
 5  192   constant[0] n
 6   32   call[0]
 7  133   goto-if-nil-else-pop [11]
          11
           0
10  193   constant[1] 1320
11  135   return

Constants Vector: [n 1320]
@end verbatim

Note the change in opcode when bytecode optimization is not performed.
@end table

@node goto-if-nil-else-pop
@unnumberedsubsec @code{goto-if-nil-else-pop} (133)
@kindex goto-if-nil-else-pop
@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is nil; otherwise pop
the TOS, the tested condition. This allows the test expression, nil,
to be used again on the branch as the TOS.
@item Generated via:
@code{cond}, @code{if} and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{\phi(0,-1)+0}
@item Example:
@code{(defun goto-if-nil-else-pop-eg(n) (cond ((n) 1330)))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  133   goto-if-nil-else-pop [6]
           6
           0
 5  193   constant[1] 1330
 6  135   return

Constants Vector: [n 1330]
@end verbatim

@end table

@node goto-if-not-nil-else-pop
@unnumberedsubsec @code{goto-if-not-nil-else-pop} (134)
@kindex goto-if-not-nil-else-pop
@table @strong
@item Implements:
Jump to label given in the 16-bit operand if TOS is not nil; otherwise
pop TOS, the tested condition. This allows the tested expression on TOS to be used
again when the jump is taken.
@item Generated via:
@code{cond}, @code{if} and various control-flow constructs
@item Operand:
16-bit PC address
@item Instruction size:
3 bytes
@item Stack effect:
@math{\phi(0,-1)+0}
@item Example:
@c ((optimize . nil))
@verbatim
(defun goto-if-not-nil-else-pop-eg(n)
  (if (or (n) (n))
    1340))
@end verbatim
generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] n
 1   32   call[0]
 2  134   goto-if-not-nil-else-pop [7]
           7
           0
 5  192   constant[0] n
 6   32   call[0]
 7  133   goto-if-nil-else-pop [11]
          11
           0
10  193   constant[1] 1340
11  135   return

Constants Vector: [n 1340]
@end verbatim

Note the change in opcode when bytecode optimization is performed.
@end table

@node return
@unnumberedsubsec @code{return} (135)
@kindex return
@table @strong
@item Implements:
Return from function.  This is the last instruction in a function's
bytecode sequence. The top value on the evaluation stack is the return value.
@item Generated via:
@code{lambda}
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+0}
@item Example:
@code{(defun return-eg(n) 1350)} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 1350
 1  135   return

Constants Vector: [1350]
@end verbatim

@end table

@node Function-Call Instructions
@section Function-Call Instructions

These instructions use up one byte, and are followed by the next
instruction directly.  They are equivalent to calling an Emacs Lisp
function with a fixed number of arguments: the arguments are popped
from the stack, and a single return value is pushed back onto the
stack.

@menu
* Lisp Function Instructions::
* List Function Instructions::
* Arithmetic Function Instructions::
* String Function Instructions::
* Emacs Function Instructions::
@end menu

@node Lisp Function Instructions
@subsection Lisp Function Instructions

These instructions correspond to general functions which are not
specific to Emacs; common cases are usually inlined for speed by the
bytecode interpreter.

@menu
* symbolp::
* consp::
* stringp::
* listp::
* eq::
* memq::
* not::
* symbol-value::
* symbol-function::
* set::
* fset::
* get::
* equal::
* member::
* assq::
* numberp::
* integerp::
@end menu

@node symbolp
@unnumberedsubsubsec @code{symbolp} (57)
@kindex symbolp
@table @strong
@item Implements:
@code{TOS <- (symbolp TOS)}.
@item Generated via:
unary @code{symbolp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun symbolp-eg(n) (symbolp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   57   symbolp
 2  135   return
@end verbatim
@end table

@node consp
@unnumberedsubsubsec @code{consp} (58)
@kindex consp
@table @strong
@item Implements:
@code{TOS <- (consp TOS)}.
@item Generated via:
unary @code{consp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun consp-eg(n) (consp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   58   consp
 2  135   return
@end verbatim
@end table

@node stringp
@unnumberedsubsubsec @code{stringp} (59)
@kindex stringp
@table @strong
@item Implements:
@code{TOS <- (stringp TOS)}.
@item Generated via:
unary @code{stringp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun stringp-eg(n) (stringp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   59   stringp
 2  135   return
@end verbatim
@end table

@node listp
@unnumberedsubsubsec @code{listp} (60)
@kindex listp
@table @strong
@item Implements:
@code{TOS <- (listp TOS)}.
@item Generated via:
unary @code{listp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun listp-eg(n) (listp n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   60   listp
 2  135   return
@end verbatim
@end table

@node eq
@unnumberedsubsubsec @code{eq} (61)
@kindex eq
@table @strong
@item Implements:
@code{S[1] <- (eq S[1] TOS); top--}.
@item Generated via:
binary @code{eq}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun eq-eg(a b) (eq a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   61   eq
 3  135   return
@end verbatim
@end table

@node memq
@unnumberedsubsubsec @code{memq} (62)
@kindex memq
@table @strong
@item Implements:
@code{S[1] <- (memq S[1] TOS); top--}.
@item Generated via:
binary @code{memq}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun memq-eg(a b) (memq a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   62   memq
 3  135   return
@end verbatim
@end table

@node not
@unnumberedsubsubsec @code{not} (63)
@kindex not
@table @strong
@item Implements:
@code{TOS <- (not TOS)}.
@item Generated via:
unary @code{not}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun not-eg(a) (not a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   63   not
 2  135   return
@end verbatim
@end table

@node symbol-value
@unnumberedsubsubsec @code{symbol-value} (74)
@kindex symbol-value
@table @strong
@item Implements:
@code{TOS <- (symbol-value TOS)}.
@item Generated via:
unary @code{symbol-value}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun symbol-value-eg(a) (symbol-value a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   74   symbol-value
 2  135   return
@end verbatim
@end table

@node symbol-function
@unnumberedsubsubsec @code{symbol-function} (75)
@kindex symbol-function
@table @strong
@item Implements:
@code{TOS <- (symbol-function TOS)}.
@item Generated via:
unary @code{symbol-function}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun symbol-function-eg(a) (symbol-function a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   75   symbol-function
 2  135   return
@end verbatim
@end table

@node set
@unnumberedsubsubsec @code{set} (76)
@kindex set
@table @strong
@item Implements:
@code{S[1] <- (set S[1] TOS); top--}.
@item Generated via:
binary @code{set}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun set-eg(a b) (set a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   76   set
 3  135   return
@end verbatim
@end table

@node fset
@unnumberedsubsubsec @code{fset} (77)
@kindex fset
@table @strong
@item Implements:
@code{S[1] <- (fset S[1] TOS); top--}.
@item Generated via:
binary @code{fset}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun fset-eg(a b) (fset a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   77   fset
 3  135   return
@end verbatim
@end table

@node get
@unnumberedsubsubsec @code{get} (78)
@kindex get
@table @strong
@item Implements:
@code{S[1] <- (get S[1] TOS); top--}.
@item Generated via:
binary @code{get}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun get-eg(a b) (get a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   78   get
 3  135   return
@end verbatim
@end table

@node equal
@unnumberedsubsubsec @code{equal} (154)
@kindex equal
@table @strong
@item Implements:
@code{S[1] <- (equal S[1] TOS); top--}.
@item Generated via:
binary @code{equal}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34
@item Example:
When lexical binding is in effect, @code{(defun equal-eg(a b) (equal a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  154   equal
 3  135   return
@end verbatim
@end table

@node member
@unnumberedsubsubsec @code{member} (157)
@kindex member
@table @strong
@item Implements:
@code{S[1] <- (member S[1] TOS); top--}.
@item Generated via:
binary @code{member}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun member-eg(a b) (member a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  157   member
 3  135   return
@end verbatim
@end table

@node assq
@unnumberedsubsubsec @code{assq} (158)
@kindex assq
@table @strong
@item Implements:
@code{S[1] <- (assq S[1] TOS); top--}.
@item Generated via:
binary @code{assq}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun assq-eg(a b) (assq a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  158   assq
 3  135   return
@end verbatim
@end table

@node numberp
@unnumberedsubsubsec @code{numberp} (167)
@kindex numberp
@table @strong
@item Implements:
@code{TOS <- (numberp TOS)}.
@item Generated via:
@code{numberp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34
@item Example:
When lexical binding is in effect, @code{(defun numberp-eg(a) (numberp a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  167   numberp
 2  135   return
@end verbatim
@end table

@node integerp
@unnumberedsubsubsec @code{integerp} (168)
@kindex integerp
@table @strong
@item Implements:
@code{TOS <- (integerp TOS)}.
@item Generated via:
@code{integerp}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Added in:
Emacs 19.34
@item Example:
When lexical binding is in effect, @code{(defun integerp-eg(a) (integerp a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1  168   integerp
 2  135   return
@end verbatim
@end table

@node List Function Instructions
@subsection List Function Instructions

These instructions correspond to general functions which are not
specific to Emacs; common cases are usually inlined for speed by the
bytecode interpreter.

@menu
* nth::
* car::
* cdr::
* cons::
* list1::
* list2::
* list3::
* list4::
* listN::
* length::
* aref::
* aset::
* nthcdr::
* elt::
* nreverse::
* setcar::
* setcdr::
* car-safe::
* cdr-safe::
* nconc::
@end menu

@node nth
@unnumberedsubsubsec @code{nth} (56)
@kindex nth

Call @code{nth} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (nth S[1] TOS); top--}.
@item Generated via:
@code{nth}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun nth-eg(l) (nth 560 l))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] 560
 1    1   stack-ref[1]
 2   56   nth
 3  135   return

Constants Vector: [560]
@end verbatim

@end table

@node car
@unnumberedsubsubsec @code{car} (64)
@kindex car

Call @code{car} with one stack argument.


@table @strong
@item Implements:
@code{TOS <- (car TOS)}.
@item Generated via:
@code{car}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun car-eg(l) (car l))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   64   car
 2  135   return
@end verbatim

@end table

@node cdr
@unnumberedsubsubsec @code{cdr} (65)
@kindex cdr

Call @code{cdr} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (cdr TOS)}.
@item Generated via:
@code{cdr}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun cdr-eg(l) (cdr l))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   65   cdr
 2  135   return
@end verbatim

@end table

@node cons
@unnumberedsubsubsec @code{cons} (66)
@kindex cons

Call @code{cons} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (cons S[1] TOS); top--}.
@item Generated via:
@code{cons}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun cons-eg() (cons 'a 'b))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2   66   cons
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table


@node list1
@unnumberedsubsubsec @code{list1} (67)
@kindex list1

Call @code{list} with one stack item.

@table @strong
@item Implements:
@code{TOS <- (list TOS)}.
@item Generated via:
@code{list}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun list1-eg() (list 'a))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1   67   list1
 2  135   return

Constants Vector: [a]
@end verbatim

@end table

Call @code{list} with one stack item.

@node list2
@unnumberedsubsubsec @code{list2} (68)

@kindex list2

Call @code{list} with two stack items.

@table @strong
@item Implements:
@code{S[1] <- (list S[1] TOS); top--}.
@item Generated via:
@code{list}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun list2-eg() (list 'a 'b))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2   68   list2
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@node list3
@unnumberedsubsubsec @code{list3} (69)
@kindex list3

Call @code{list} with three stack items.

@table @strong
@item Implements:
@code{S[2] <- (list S[2] S[1] TOS); top -= 2}.
@item Generated via:
@code{list}
@item Instruction size:
1 byte
@item Stack effect:
@math{-3+1}.
@item Example:
@code{(defun list3-eg() (list 'a 'b 'c))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2  194   constant[2] c
 3   69   list3
 4  135   return

Constants Vector: [a b c]
@end verbatim

@end table

@node list4
@unnumberedsubsubsec @code{list4} (70)
@kindex list4
Call @code{list} with four items.

@table @strong
@item Implements:
@code{S[3] <- (list S[3] S[2] S[1] TOS); top -= 2}.
@item Generated via:
@code{list}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-4+1}.
@item Example:
@code{(defun list4-eg() (list 'a 'b 'c 'd))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2  194   constant[2] c
 3  195   constant[3] d
 4   70   list4
 5  135   return

Constants Vector: [a b c d]
@end verbatim

@end table

@node listN
@unnumberedsubsubsec @code{listN} (175)
@kindex listN
Call @code{list} on up to 255 items. Note that there are special
instructions for the case where there are 1 to 4 items in the list.

@table @strong
@item Implements:
@code{S[n-1] <- (list S[n-1] S[n-2] ... TOS); top -= (n-1)}.
@item Generated via:
@code{list}.
@item Operand:
8-bit number of items in list
@item Instruction size:
2 bytes
@item Stack effect:
@math{-n+1} where @math{n} is the value of the instruction operand.
@item Added in:
Emacs 19.34.
@item Example:
@code{(defun list4-eg() (list 'a 'b 'c 'd 'e))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] a
 1  193   constant[1] b
 2  194   constant[2] c
 3  195   constant[3] d
 4  196   constant[4] e
 5  175   listN [5]
           5
 7  135   return

Constants Vector: [a b c d e]
@end verbatim

@end table


@node length
@unnumberedsubsubsec @code{length} (71)
@kindex length
Call @code{length} with one stack argument.

@table @strong
@item Implements:
@code{TOS <- (length TOS)}.
@item Generated via:
@code{length}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
@code{(defun length-eg() (length '(a b)))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] (a b)
 1   71   length
 2  135   return

Constants Vector: [(a b)]
@end verbatim

@end table

@node aref
@unnumberedsubsubsec @code{aref} (72)
@kindex aref
Call @code{aref} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (aref S[1] TOS); top--}.
@item Generated via:
@code{aref}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun aref-eg() (aref '[720 721 722] 0))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] [720 721 722]
 1  193   constant[1] 0
 2   72   aref
 3  135   return

Constants Vector: [[720 721 722] 0]
@end verbatim

@end table

@node aset
@unnumberedsubsubsec @code{aset} (73)
@kindex aset
Call @code{aset} with three stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (aref S[1] TOS); top--}.
@item Generated via:
@code{aset}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
@code{(defun aset-eg() (aset array-var 0 730))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0    8   varref[0] array-var
 1  193   constant[1] 0
 2  194   constant[2] 730
 3   73   aset
 4  135   return

Constants Vector: [array-var 0 730]
@end verbatim

@end table


@node nthcdr
@unnumberedsubsubsec @code{nthcdr} (155)
@kindex nthcdr
Call @code{nthcdr} with two stack arguments.

@table @strong
@item Implements:
@code{S[1] <- (nthcdr S[1] TOS); top --}.
@item Generated via:
@code{aset}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34.
@item Example:
@code{(defun ntthcdr() (ntchcdr '(1550 1551 1552) 2))} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  192   constant[0] ntchcdr
 1  193   constant[1] (1550 1551 1552)
 2  194   constant[2] 2
 3   34   call[2]
 4  135   return

Constants Vector: [ntchcdr (1550 1551 1552) 2]
@end verbatim

@end table


@node elt
@unnumberedsubsubsec @code{elt} (156)
@kindex elt
Call @code{elt} with two stack arguments.

Added in Emacs 19.34.

@node nreverse
@unnumberedsubsubsec @code{nreverse} (159)
@kindex nreverse
Call @code{nreverse} with one argument.

Added in Emacs 19.34.

@node setcar
@unnumberedsubsubsec @code{setcar} (160)
@kindex setcar
Call @code{setcar} with two stack arguments.

Added in Emacs 19.34.

@node setcdr
@unnumberedsubsubsec @code{setcdr} (161)
@kindex setcdr
Call @code{setcdr} with two stack arguments.

Added in Emacs 19.34.

@node car-safe
@unnumberedsubsubsec @code{car-safe} (162)
@kindex car-safe
Call @code{car-safe} with one argument.

Added in Emacs 19.34.

@node cdr-safe
@unnumberedsubsubsec @code{cdr-safe} (163)
@kindex cdr-safe
Call @code{cdr-safe} with one argument.

Added in Emacs 19.34.
@node nconc
@unnumberedsubsubsec @code{nconc} (164)
@kindex nconc
Call @code{nconc} with two stack arguments.

Added in Emacs 19.34.

@node Arithmetic Function Instructions
@subsection Arithmetic Function Instructions

These instructions correspond to general functions which are not
specific to Emacs; common cases are usually inlined for speed by the
bytecode interpreter.

@menu
* sub1::
* add1::
* eqlsign::
* gtr::
* lss::
* leq::
* geq::
* diff::
* negate::
* plus::
* mult::
* max::
* min::
* quo::
* rem::
@end menu

@node sub1
@unnumberedsubsubsec @code{sub1} (83)
@kindex sub1

@table @strong
@item Implements:
@code{TOS <- (1- TOS)}.
@item Generated via:
@code{1-}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun sub1-eg(n) (1- n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   83   sub1
 2  135   return
@end verbatim

@end table

@node add1
@unnumberedsubsubsec @code{add1} (84)
@kindex add1

@table @strong
@item Implements:
@code{TOS <- (1+ TOS)}.
@item Generated via:
unary @code{-}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun add1-eg(n) (1+ n))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0  137   dup
 1   84   add1
 2  135   return
@end verbatim

@end table

@node eqlsign
@unnumberedsubsubsec @code{eqlsign} (85)
@kindex eqlsign

@table @strong
@item Implements:
@code{S[1] <- (= S[1] TOS; top--)}.
@item Generated via:
binary @code{=}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun eqlsign-eg(a b) (= a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   85   eqlsign
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@node gtr
@unnumberedsubsubsec @code{gtr} (86)
@kindex gtr

@table @strong
@item Implements:
@code{S[1] <- (> S[1] TOS; top--)}.
@item Generated via:
binary @code{>}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun gtr-eg(a b) (> a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   86   gtr
 3  135   return
@end verbatim

@end table

@node lss
@unnumberedsubsubsec @code{lss} (87)
@kindex lss

@table @strong
@item Implements:
@code{S[1] <- (< S[1] TOS; top--)}.
@item Generated via:
binary @code{<}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun lss-eg(a b) (< a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   87   lss
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@node leq
@unnumberedsubsubsec @code{leq} (88)
@kindex leq

@table @strong
@item Implements:
@code{S[1] <- (<= S[1] TOS; top--)}.
@item Instruction size:
1 byte
@item Generated via:
binary @code{<=}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun leq-eg(a b) (<= a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   88   leq
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@node geq
@unnumberedsubsubsec @code{geq} (89)
@kindex geq

@table @strong
@item Implements:
@code{S[1] <- (>= S[1] TOS; top--)}.
@item Instruction size:
1 byte
@item Generated via:
binary @code{>=}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun geq-eg(a b) (>= a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   89   geq
 3  135   return
@end verbatim

@end table

@node diff
@unnumberedsubsubsec @code{diff} (90)
@kindex diff

@table @strong
@item Implements:
@code{S[1] <- (- S[1] TOS; top--)}.
@item Generated via:
binary @code{-}.
@item Instruction size:
1 byte
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When lexical binding is in effect, @code{(defun diff-eg(a b) (- a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2   90   diff
 3  135   return
@end verbatim

@end table

@node negate
@unnumberedsubsubsec @code{negate} (91)
@kindex negate

@table @strong
@item Implements:
@code{TOS <- (- TOS)}.
@item Generated via:
unary @code{-}.
@item Instruction size:
1 byte
@item Instruction size:
1 byte
@item Stack effect:
@math{-1+1}.
@item Example:
When lexical binding is in effect, @code{(defun negate-eg(a) (- a))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1   91   negate
 2  135   return

Constants Vector: [a]
@end verbatim

@end table

@node plus
@unnumberedsubsubsec @code{plus} (92)
@kindex plus

@table @strong
@item Implements:
@code{S[1] <- (+ S[1] TOS; top--)}.
@item Generated via:
binary @code{+}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun plus-eg(n) (+ n n))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] n
 1  137   dup
 2   92   plus
 3  135   return

Constants Vector: [n]
@end verbatim

@end table

@node mult
@unnumberedsubsubsec @code{mult} (95)
@kindex mult

@table @strong
@item Implements:
@code{S[1] <- (* S[1] TOS; top--)}.
@item Generated via:
binary @code{*}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Added in:
Emacs 19.34
@item Example:
When dynamic binding is in effect, @code{(defun mult-eg(n) (* n n))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] n
 1  137   dup
 2   95   mult
 3  135   return

Constants Vector: [n]
@end verbatim

@end table

@node max
@unnumberedsubsubsec @code{max} (93)
@kindex max

@table @strong
@item Implements:
@code{S[1] <- (max S[1] TOS; top--)}.
@item Generated via:
binary @code{max}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun max-eg(a b) (max a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   93   max
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@node min
@unnumberedsubsubsec @code{min} (94)
@kindex min

@table @strong
@item Implements:
@code{TOS <- (min(S[1] TOS)}.
@item Generated via:
binary @code{min}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun min-eg(a b) (min a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2   94   min
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@node quo
@unnumberedsubsubsec @code{quo} (165)
@kindex quo

@table @strong
@item Implements:
@code{S[1] <- (/ S[1] TOS; top--)}.
@item Generated via:
binary @verb{|/|}.
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}.
@item Example:
When dynamic binding is in effect, @code{(defun min-quo(a b) (/ a b))} generates:
@verbatim
PC  Byte  Instruction
 0    8   varref[0] a
 1    9   varref[1] b
 2  165   quo
 3  135   return

Constants Vector: [a b]
@end verbatim

@end table

@node rem
@unnumberedsubsubsec @code{rem} (166)
@kindex rem

@table @strong
@item implements:
@code{S[1] <- (% S[1] TOS; top--)}.
@item generated via:
binary @verb{|%|}
@item Instruction size:
1 byte
@item Stack effect:
@math{-2+1}
@item Added in:
Emacs 19.34.
@item Example:
When lexical binding is in effect, @code{(defun rem-eg(a b) (% a b))} generates:
@c ((lexical . t))
@verbatim
PC  Byte  Instruction
 0    1   stack-ref[1]
 1    1   stack-ref[1]
 2  166   rem
 3  135   return
@end verbatim

@end table

@node String Function Instructions
@subsection String Function Instructions

These instructions correspond to general functions which are not
specific to Emacs; the bytecode interpreter calls the corresponding C
function for them.

@menu
* substring::
* concat2::
* concat3::
* concat4::
* concatN::
* upcase::
* downcase::
* stringeqlsign::
* stringlss::
@end menu

@node substring
@unnumberedsubsubsec @code{substring} (79)
@kindex substring
Call @code{substring} with three stack arguments.

@node concat2
@unnumberedsubsubsec @code{concat2} (80)
@kindex concat2
Call @code{concat} with two stack arguments.

@node concat3
@unnumberedsubsubsec @code{concat3} (81)
@kindex concat3
Call @code{concat} with three stack arguments.

@node concat4
@unnumberedsubsubsec @code{concat4} (82)
@kindex concat4
Call @code{concat} with four stack stack arguments.


@node concatN
@unnumberedsubsubsec @code{concatN} (174)
@kindex concatN

Call @code{concat} on up to 255 stack arguments.  Note there are
special instructions for the case where there are 2 to 4 items to
concatenate.

Added in Emacs 19.34.

@node upcase
@unnumberedsubsubsec @code{upcase} (150)
@kindex upcase
Call @code{upcase} with one argument.

Added in Emacs 19.34.

@node downcase
@unnumberedsubsubsec @code{downcase} (151)
@kindex downcase
Call @code{downcase} with one argument.

Added in Emacs 19.34.

@node stringeqlsign
@unnumberedsubsubsec @code{stringeqlsign} (152)
@kindex stringeqlsign
Call @code{string=} with two arguments, comparing two strings for equality.

Added in Emacs 19.34.

@node stringlss
@unnumberedsubsubsec @code{stringlss} (153)
@kindex stringlss
Call @code{string<} with two arguments, comparing two strings.

Added in Emacs 19.34.

@node Emacs Function Instructions
@subsection Emacs Function Instructions

These instructions correspond to Emacs-specific text manipulation
functions. They are generally not inlined by the bytecode interpreter,
but simply call the corresponding C function.

@menu
* point::
* goto-char::
* insert::
* insertN::
* point-max::
* point-min::
* char-after::
* following-char::
* preceding-char::
* current-column::
* eolp::
* eobp::
* bolp::
* bobp::
* current-buffer::
* set-buffer::
* save-current-buffer::
* forward-char::
* forward-word::
* skip-chars-forward::
* skip-chars-backward::
* forward-line::
* char-syntax::
* buffer-substring::
* delete-region::
* narrow-to-region::
* widen::
* end-of-line::
* set-marker::
* match-beginning::
* match-end::
@end menu

@node point
@unnumberedsubsubsec @code{point} (96)
@kindex point
Call @code{point}.

@node goto-char
@unnumberedsubsubsec @code{goto-char} (98)
@kindex goto-char
Call @code{goto-char} with one argument.

@node insert
@unnumberedsubsubsec @code{insert} (99)
@kindex insert
Call @code{insert} with one argument.

@node insertN
@unnumberedsubsubsec @code{insert} (99)
@kindex insertN
Call @code{insert} on up to 255 stack arguments.  Note there are special
instructions when there is only one argument.

Added in Emacs 19.34.

@node point-max
@unnumberedsubsubsec @code{point-max} (100)
@kindex point-max
Call @code{point-max}.

@node point-min
@unnumberedsubsubsec @code{point-min} (101)
@kindex point-min
Call @code{point-min}.

@node char-after
@unnumberedsubsubsec @code{char-after} (102)
@kindex char-after
Call @code{char-after} with one argument.

@node following-char
@unnumberedsubsubsec @code{following-char} (103)
@kindex following-char
Call @code{following-char}.

@node preceding-char
@unnumberedsubsubsec @code{preceding-char} (104)
@kindex preceding-char
Call @code{preceding-char}.

@node current-column
@unnumberedsubsubsec @code{current-column} (105)
@kindex current-column
Call @code{current-column}.

@node eolp
@unnumberedsubsubsec @code{eolp} (108)
@kindex eolp
Call @code{eolp}.

@node eobp
@unnumberedsubsubsec @code{eobp} (109)
@kindex eobp
Call @code{eobp}.

@node bolp
@unnumberedsubsubsec @code{bolp} (110)
@kindex bolp
Call @code{bolp}.

@node bobp
@unnumberedsubsubsec @code{bobp} (111)
@kindex bobp
Call @code{bobp}.

@node current-buffer
@unnumberedsubsubsec @code{current-buffer} (112)
@kindex current-buffer
Call @code{current-buffer}.

@node set-buffer
@unnumberedsubsubsec @code{set-buffer} (113)
@kindex set-buffer
Call @code{set-buffer} with the top of the stack,
The top of the stack is replaced by the result of
@code{(set-buffer TOS)}

@strong{Example}
@code{(defun set-buffer-eg() (set-buffer "*scratch"))} generates:
@verbatim
PC  Byte  Instruction
 0  192   constant[0] "*scratch"
 1  113   set-buffer
 2  135   return

Constants Vector: ["*scratch"]
@end verbatim

@node save-current-buffer
@unnumberedsubsubsec @code{save-current-buffer} (114)
@kindex save-current-buffer
Call @code{save-current-buffer}.

Replaces older @code{save-current-buffer-OBSOLETE}.

Added in Emacs 19.34.

@strong{Example}
@code{(defun scb() (save-current-buffer (prog 5)))} generates:
@verbatim
PC  Byte  Instruction
 0  114   save-current-buffer
 1  192   constant[0] prog
 2  193   constant[1] 5
 3   33   call[1]
 4   41   unbind[1]
 5  135   return

Constants Vector: [prog 5]
@end verbatim

@node forward-char
@unnumberedsubsubsec @code{forward-char} (117)
@kindex forward-char
Call @code{forward-char} with one argument.

Added in Emacs 19.34.

@node forward-word
@unnumberedsubsubsec @code{forward-word} (118)
@kindex forward-word
Call @code{forward-word} with one argument.

Added in Emacs 19.34.

@node skip-chars-forward
@unnumberedsubsubsec @code{skip-chars-forward} (119)
@kindex skip-chars-forward
Call @code{skip-chars-forward} with two stack arguments.

Added in Emacs 19.34.

@node skip-chars-backward
@unnumberedsubsubsec @code{skip-chars-backward} (120)
@kindex skip-chars-backward
Call @code{skip-chars-backward} with two stack arguments.

Added in Emacs 19.34.

@node forward-line
@unnumberedsubsubsec @code{forward-line} (121)
@kindex forward-line
Call @code{forward-line} with one argument.

Added in Emacs 19.34.

@node char-syntax
@unnumberedsubsubsec @code{char-syntax} (122)
@kindex char-syntax
Call @code{char-syntax} with one argument.

Added in Emacs 19.34.

@node buffer-substring
@unnumberedsubsubsec @code{buffer-substring} (123)
@kindex buffer-substring
Call @code{buffer-substring} with two stack arguments.

Added in Emacs 19.34.

@node delete-region
@unnumberedsubsubsec @code{delete-region} (124)
@kindex delete-region
Call @code{delete-region} with two stack arguments.

Added in Emacs 19.34.

@node narrow-to-region
@unnumberedsubsubsec @code{narrow-to-region} (125)
@kindex narrow-to-region
Call @code{narrow-to-region} with two stack arguments.

Added in Emacs 19.34.

@node widen
@unnumberedsubsubsec @code{widen} (126)
@kindex widen
Call @code{widen}.

Added in Emacs 19.34.

@node end-of-line
@unnumberedsubsubsec @code{end-of-line} (127)
@kindex end-of-line
Call @code{end-of-line} with one argument.

Added in Emacs 19.34.

@node set-marker
@unnumberedsubsubsec @code{set-marker} (147)
@kindex set-marker
Call @code{set-marker} with three stack arguments.

Added in Emacs 19.34.

@node match-beginning
@unnumberedsubsubsec @code{match-beginning} (148)
@kindex match-beginning
Call @code{match-beginning} with one argument.

Added in Emacs 19.34.

@node match-end
@unnumberedsubsubsec @code{match-end} (149)
@kindex match-end
Call @code{match-end} with one argument.

Added in Emacs 19.34.

@node Stack Manipulation Instructions
@section Stack Manipulation Instructions

@menu
* discard::
* discardN::
* dup::
* stack-set::
* stack-set2::
@end menu

@node discard
@unnumberedsubsec @code{discard} (136)
@kindex discard
Discard one value from the stack.

@node discardN
@unnumberedsubsec @code{discardN} (180)
@kindex discardN
Discards up to 255 arguments from the stack.  Note there is a special
instruction when there is only one argument.

Added in Emacs 24.1

@node dup
@unnumberedsubsec @code{dup} (137)
@kindex dup
Make a copy of the top-of-stack value and push that onto the top of the evaluation stack.

@subsubsection Example
When lexical binding is in effect, @code{(defun en(n) n)} generates:
@c ((lexical . t) (optimize . nil))
@verbatim
PC  Byte  Instruction
 0  137   dup  ;; duplicates top of stack: n
 1  135   return
@end verbatim

@node stack-set
@unnumberedsubsec @code{stack-set} (180)
@kindex stack-set
Like discard. [What's the difference?]

Added in Emacs 24.1

@node stack-set2
@unnumberedsubsec @code{stack-setN} (181)
@kindex stack-set2
Like discardN. [What's the difference?]
Can handle up to 255 stack arguments.  Note there is a special
instruction when there is only one argument.

Added in Emacs 24.1

@node Binding Instructions
@section Binding Instructions

These instructions manipulate the special-bindings stack by creating a
new binding when executed.  They need to be balanced with
@code{unbind} instructions.

@unnumberedsubsec @code{save-excursion} (138)
@kindex save-excursion
Make a binding recording buffer, point, and mark.
